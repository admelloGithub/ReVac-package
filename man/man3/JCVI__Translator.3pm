.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "JCVI::Translator 3"
.TH JCVI::Translator 3 "2008-09-11" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
JCVI::Translator \- Translate DNA sequences
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use JCVI::Translator;
.Ve
.PP
.Vb 5
\&    my $translator = new JCVI::Translator();
\&    my $translator = new JCVI::Translator(11);
\&    my $translator = new JCVI::Translator( 12, 'id' );
\&    my $translator = new JCVI::Translator( 'Yeast Mitochondrial', 'name' );
\&    my $translator = new JCVI::Translator( 'mito', 'name' );
.Ve
.PP
.Vb 2
\&    my $translator = custom JCVI::Translator( \e$custom_table );
\&    my $translator = custom JCVI::Translator( \e$custom_table, 1 );
.Ve
.PP
.Vb 3
\&    $translator->translate( \e$seq );
\&    $translator->translate( \e$seq, { strand => 1 } );
\&    $translator->translate( \e$seq, { strand => -1 } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
JCVI::Translator tries to be a robust translator object featuring translation
tables based off the the ones provided by \s-1NCBI\s0
(http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi).
Key features include the ability to handle degenerate nucleotides and to
translate to ambiguous amino acids.
.PP
The way to work with JCVI::Translator is you create a new translator using an
internal translation table or a provided one, this module will translate \s-1DNA\s0
sequences for you.
.PP
Translator uses interbase coordinates. See below for the difference between
interbase coordinates and traditional numbering methods:
.PP
.Vb 3
\&    Traditional   1 2 3 4
\&                  A C G T ...
\&    Interbase    0 1 2 3 4
.Ve
.PP
Conversion methods between the two methods can depend upon what you are trying
to do, but the simple way to do this is:
.PP
.Vb 3
\&    strand = 3' end <=> 5' end
\&    lower  = min( 5' end, 3' end ) - 1
\&    upper  = max( 5' end, 3' end )
.Ve
.PP
For logging, it uses Log::Log4Perl. This needs to be initialized to work.
.PP
For parameter validation, uses Params::Validate. This
introduces a bit of overhead, however, for scripts that are
fully tested, validation can be disabled. See the
Params::Validate documentation.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.Sh "new"
.IX Subsection "new"
.Vb 3
\&    my $translator = new JCVI::Translator();
\&    my $translator = new JCVI::Translator( $id );
\&    my $translator = new JCVI::Translator( $id, \e%params );
.Ve
.PP
Create a translator with a translation table provided by \f(CW$id\fR. Please see
JCVI::Translator::Table for the full list of options.
.Sh "\fIcustom()\fP"
.IX Subsection "custom()"
.Vb 2
\&    my $translator = $translator->custom( $table_ref );
\&    my $translator = $translator->custom( $table_ref, \e%params );
.Ve
.PP
Create a translator with a custom translation table. Please see
JCVI::Translator::Table for the full list of options.
.SH "METHODS"
.IX Header "METHODS"
.Sh "translate"
.IX Subsection "translate"
.Vb 1
\&    $pep_ref = $translator->translate( $seq_ref, \e%params );
.Ve
.PP
The basic function of this module. Translate the specified region of the
sequence (passed as \f(CW$seq_ref\fR) and return a reference to the translated string.
The parameters are:
.PP
.Vb 5
\&    strand:     1 or -1; default = 1
\&    lower:      integer between 0 and length; default = 0
\&    upper:      integer between 0 and length; default = length
\&    partial:    0 or 1; default = 0
\&    sanitized:  0 or 1; default = 0
.Ve
.PP
Translator uses interbase coordinates. lower and upper are optional parameters
such that:
.PP
.Vb 1
\&    0 <= lower <= upper <= length
.Ve
.PP
Translator will log and die if those conditions are not satisfied.
.PP
partial sets whether or not the sequence is a 5' partial. By default, partial
is taken to be false  and the translator will try to translate the first codon
as if it were a start codon. You can specify that the sequence is 5' partial
and the translator will skip that step.
.PP
sanitized is a flag translator know that this sequence has been stripped of
whitespace and that all the codons are capitalized. Otherwise, translator will
do that in order to speed up the translation process (see
JCVI::DNATools::cleanDNA).
.PP
To translate the following:
.PP
.Vb 3
\& 0 1 2 3 4 5 6 7 8 9
\&  C G C G C A G G A
\&    ---------->
.Ve
.PP
.Vb 8
\&    $pep_ref = $translator->translate(
\&        \e$sequence,
\&        {
\&            strand => 1,
\&            lower  => 1,
\&            upper  => 7
\&        }
\&    );
.Ve
.PP
.Vb 3
\& 0 1 2 3 4 5 6 7 8 9
\&  C G C G C A G G A
\&      <----------
.Ve
.PP
.Vb 8
\&    $pep_ref = $translator->translate(
\&        \e$sequence,
\&        {
\&            strand => -1,
\&            lower  => 2,
\&            upper  => 8
\&        }
\&    );
.Ve
.PP
Examples:
.PP
.Vb 1
\&    my $pep_ref = $translator->translate( \e'acttgacgt' );
.Ve
.PP
.Vb 1
\&    my $pep_ref = $translator->translate( \e'acttgacgt', { strand => -1 } );
.Ve
.PP
.Vb 8
\&    my $pep_ref = $translator->translate(
\&        \e'acttgacgt',
\&        {
\&            strand => -1,
\&            lower  => 2,
\&            upper  => 5
\&        }
\&    );
.Ve
.PP
.Vb 9
\&    my $pep_ref = $translator->translate(
\&        \e'acttgacgt',
\&        {
\&            strand  => 1,
\&            lower   => 0,
\&            upper   => 8,
\&            partial => 0
\&        }
\&    );
.Ve
.Sh "translate6"
.IX Subsection "translate6"
.Vb 2
\&    my $pep_refs = $translator->translate6( $seq_ref );
\&    my $pep_refs = $translator->translate6( $seq_ref, \e%params );
.Ve
.PP
Translate the sequence in every possible way. Returns an array reference of all
the translations. The structure of the array is as follows:
.PP
.Vb 7
\&    0: ---------->
\&    1:  --------->
\&    2:   -------->
\&       NNNN...NNNN
\&    3: <----------
\&    4: <---------
\&    5: <--------
.Ve
.PP
The parameters are similar to those use in translate:
.PP
.Vb 4
\&    lower:      integer between 0 and length; default = 0
\&    upper:      integer between 0 and length; default = length
\&    partial:    0 or 1; default = 0
\&    sanitized:  0 or 1; default = 0
.Ve
.PP
Example:
.PP
.Vb 1
\&    $pep_refs = $translator->translate6(\e'acttgacgt');
.Ve
.PP
Output:
.PP
.Vb 8
\&    $pep_refs = [
\&                    $pep1,
\&                    $pep2,
\&                    $pep3,
\&                    $reverse_pep1,
\&                    $reverse_pep2,
\&                    $reverse_pep3
\&                ]
.Ve
.Sh "translate_exons"
.IX Subsection "translate_exons"
.Vb 2
\&    my $pep_ref = translate_exons( $str_ref, $exons_array_ref );
\&    my $pep_ref = translate_exons( $str_ref, $exons_array_ref, \e%params );
.Ve
.PP
Translate a gene spanning multiple exons. Paramters are:
.PP
.Vb 3
\&    strand:     1 or -1; default = 1
\&    partial:    0 or 1;  default = 0
\&    sanitized:  0 or 1;  default = 0
.Ve
.PP
Input:
.PP
.Vb 5
\&    $exons_array_ref = [
\&                            [$start0, $stop0],
\&                            [$start1, $stop1],
\&                            ...
\&                       ];
.Ve
.PP
The order of the exons in the array doesn't matter. translate_exons will sort
the exons.
.PP
Example:
.PP
.Vb 2
\&    $pep_ref = translate_exons(\e'actgcat', [ [0,2], [3,7] ]);
\&    $pep_ref = translate_exons(\e'actgcat', [ [0,2], [3,7] ], { strand => -1});
.Ve
.Sh "translate_codon"
.IX Subsection "translate_codon"
.Vb 2
\&    my $residue = $translator->translate_codon( $codon );
\&    my $residue = $translator->translate_codon( $codon, \e%params );
.Ve
.PP
Translate a codon. Return 'X' or '\-' if it isn't in the
codon table. Handles degenerate nucleotides, so if all
possible codons for an ambiguity map to the same residue,
return that residue.
.PP
Example:
.PP
.Vb 3
\&    $residue = $translator->translate_codon('atg');
\&    $residue = $translator->translate_codon( 'tty', { strand => -1 } );
\&    $residue = $translator->translate_codon( 'cat', { start => 1 } );
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Kevin Galinsky, \f(CW\*(C`<kgalinsk at jcvi.org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-jcvi\-translator at rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=JCVI\-Translator>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc JCVI::Translator
.Ve
.PP
You can also look for information at:
.IP "* AnnoCPAN: Annotated \s-1CPAN\s0 documentation" 4
.IX Item "AnnoCPAN: Annotated CPAN documentation"
<http://annocpan.org/dist/JCVI\-Translator>
.IP "* \s-1CPAN\s0 Ratings" 4
.IX Item "CPAN Ratings"
<http://cpanratings.perl.org/d/JCVI\-Translator>
.IP "* \s-1RT:\s0 \s-1CPAN\s0's request tracker" 4
.IX Item "RT: CPAN's request tracker"
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=JCVI\-Translator>
.IP "* Search \s-1CPAN\s0" 4
.IX Item "Search CPAN"
<http://search.cpan.org/dist/JCVI\-Translator>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Log::Log4perl
Params::Validate
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2008\-2009 J. Craig Venter Institute, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
