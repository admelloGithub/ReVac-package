.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TIGR::FASTArecord 3"
.TH TIGR::FASTArecord 3 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
TIGR::FASTArecord \- TIGR::FASTArecord class describing FASTA records
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use TIGR::FASTArecord;
\&  my $obj_instance = new TIGR::FASTArecord ($record_header,
\&                                            $record_data);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object definition for a \s-1FASTA\s0 record.  It verifies
data entry on creation, and returns information queried on the record.
.ie n .IP "$obj_instance = new TIGR::FASTArecord ($header, $data_rec);" 4
.el .IP "$obj_instance = new TIGR::FASTArecord ($header, \f(CW$data_rec\fR);" 4
.IX Item "$obj_instance = new TIGR::FASTArecord ($header, $data_rec);"
This method returns a new instance of a TIGR::FASTArecord object.  It takes
a record header, \f(CW$header\fR, and the record data, \f(CW$data_rec\fR as parameters.
The record header may optionally contain the leading header character, a 
\&\f(CW\*(C`<gt\*(C'\fR> symbol.  Both parameters are parsed.  A new object instance is
returned on success.  If parsing fails or a record cannot be created, this
method returns undefined.
.ie n .IP "$result = $obj_instance\->equals($fasta_obj);" 4
.el .IP "$result = \f(CW$obj_instance\fR\->equals($fasta_obj);" 4
.IX Item "$result = $obj_instance->equals($fasta_obj);"
This method takes a \fITIGR::FASTArecord\fR object as a parameter.  It compares
the passed object with the calling object's internal structures to test for
equality.  If the two objects are equal, this method returns true (1). 
Otherwise, this method returns false (undefined).
.ie n .IP "$identifier = $obj_instance\fR\->\fIgetHeader();" 4
.el .IP "$identifier = \f(CW$obj_instance\fR\->\fIgetHeader()\fR;" 4
.IX Item "$identifier = $obj_instance->getHeader();"
This method returns the header string for the record.
.ie n .IP "$identifier = $obj_instance\fR\->\fIgetIdentifier();" 4
.el .IP "$identifier = \f(CW$obj_instance\fR\->\fIgetIdentifier()\fR;" 4
.IX Item "$identifier = $obj_instance->getIdentifier();"
This method returns the identifier string for the record.
.ie n .IP "$data_contents = $obj_instance\fR\->\fIgetData();" 4
.el .IP "$data_contents = \f(CW$obj_instance\fR\->\fIgetData()\fR;" 4
.IX Item "$data_contents = $obj_instance->getData();"
This method returns the data contents of the record as an 
uninterrupted string.
.ie n .IP "$size_of_rec = $obj_instance\fR\->\fIsize();" 4
.el .IP "$size_of_rec = \f(CW$obj_instance\fR\->\fIsize()\fR;" 4
.IX Item "$size_of_rec = $obj_instance->size();"
This method returns the size of the data string contained by the
record.
.ie n .IP "$str_rep = $obj_instance\fR\->\fItoString();" 4
.el .IP "$str_rep = \f(CW$obj_instance\fR\->\fItoString()\fR;" 4
.IX Item "$str_rep = $obj_instance->toString();"
This method returns a string representation of the \s-1FASTA\s0 record.
This string representation conforms to the \s-1TIGR\s0 definition of a
\&\s-1FASTA\s0 record.
.ie n .IP "$rev_compl_str = $obj_instance\->reverseComplement($NA_strand);" 4
.el .IP "$rev_compl_str = \f(CW$obj_instance\fR\->reverseComplement($NA_strand);" 4
.IX Item "$rev_compl_str = $obj_instance->reverseComplement($NA_strand);"
This method takes in a string which represents a Nucleotide strand and
returns the reverse complement of the strand. If the string does not 
represent a Nucleotide strand or is undefined, the method returns undefined. 
When an empty string is passed into the method, we get an empty string on 
return.
.ie n .IP "$rev_compl_str = $obj_instance\fR\->\fIreverseComplementData();" 4
.el .IP "$rev_compl_str = \f(CW$obj_instance\fR\->\fIreverseComplementData()\fR;" 4
.IX Item "$rev_compl_str = $obj_instance->reverseComplementData();"
This method returns the reverse complement of the \s-1FASTA\s0 record data. If the 
\&\s-1FASTA\s0 record data does not represent a Nucleotide strand or is undefined, the 
method returns undefined.
.ie n .IP "$data_substr = $obj_instance\fR\->subSequence($startpos, \f(CW$length);" 4
.el .IP "$data_substr = \f(CW$obj_instance\fR\->subSequence($startpos, \f(CW$length\fR);" 4
.IX Item "$data_substr = $obj_instance->subSequence($startpos, $length);"
This method behaves like \fIsubstr()\fR. This method takes in two numbers \f(CW$startpos\fR 
and \f(CW$length\fR and returns a substring of the record data. The \f(CW$startpos\fR for the 
first base in the data is 0. The \f(CW$length\fR is optional. The substring is 
extracted starting at \f(CW$startpos\fR characters from the front of the data string. 
If \f(CW$startpos\fR is negative, the substring starts that far from the end of the 
string instead. If \f(CW$length\fR is omitted, everything to the end of the string is 
returned. If \f(CW$length\fR is negative, the length is calculated to leave that many 
characters off the end of the string. Otherwise, \f(CW$length\fR indicates the length 
of the substring to extract. If \f(CW$startpos\fR is undefined the function returns 
undefined. If either \f(CW$startpos\fR or \f(CW$length\fR are greater than the data length, the
method returns undefined
.ie n .IP "$result = $obj_instance\fR\->\fIunGap();" 4
.el .IP "$result = \f(CW$obj_instance\fR\->\fIunGap()\fR;" 4
.IX Item "$result = $obj_instance->unGap();"
This method removes all the gaps('\-' characters) from the record data. The 
record size is changed after the gaps are removed. The method returns 1 on 
success and undefined otherwise.
.SH "USAGE"
.IX Header "USAGE"
To use this module, load it using the \f(CW\*(C`use\*(C'\fR function.  The object must
be initialized with a header and a data string.  An example follows.
Please refer to the \f(CW\*(C`TIGR::FASTAreader\*(C'\fR package usage for more examples.
.PP
.Vb 1
\&   #!/usr/local/bin/perl -w
.Ve
.PP
.Vb 2
\&   use strict;
\&   use TIGR::FASTArecord;
.Ve
.PP
.Vb 2
\&   MAIN:
\&   {
.Ve
.PP
.Vb 17
\&      # set up a simple example without using the leading carot.
\&      my $header1 = "ORF00001 The first ORF in the series";
\&      my $data1 = 
\&         "MEEISTPEGGVLVPISIETEVKRAYIDYSMSVIVSRALPDVRDGLKPVHRRILYAMEEKG" .
\&         "LRFSGPTRKCAKIVGDVLGSFHPHGDASVYDALVRLGQDFSLRYPVIHPQGNFGTIGGDP" .
\&         "PAAYRYTEAKMARIAESMVEDIKKETVSFVPNFDDSDVEPTVLPGRFPFLLANGSSGIAV" .
\&         "GMTTNMPPHNLREIAAAISAYIENPNLSIQELCDCINGPDFPTGGIIFGKNGIRQSYETG" .
\&         "RGKIVVRARFTIETDSKGRDTIIFTEVPYQVNTTMLVMRIGELARAKVIEGIANVNDETS" .
\&         "DRTGLRIVVELKKGTPAQVVLNHLFAKTPLQSSFNVINLALVEGRPRMLTLKDLVRYFVE" .
\&         "HRVDVVTRRAHFELRKAQERIHLVRALIRALDAIDKIITLIRHSQNTELAKQRLREQFDF" .
\&         "DNVQAQAIVDMQMKRLTGLEVESLRTELKDLTELISSLEELLTSPQKVLGVVKKETRDIA" .
\&         "DMFGDDRRTDIVSNEIEYLDVEDFIQKEEMVILISHLGYIKRVPVSAYRNQNRGGKGSSS" .
\&         "ANLAAHDFISQIFTASTHDYVMFVTSRGRAYWLKVYGIPESGRANRGSHIKSLLMVATDE" .
\&         "EITAIVSLREFSNKSYVFMATARGVVKKVTTDNFVNAKTRGIIALKLSGGDTLVSAVLVQ" .
\&         "DEDEVMLITRQGKALRMSGREVREMGRNSSGVIGIKLTSEDLVAGVLRVSEQRKVLIMTE" .
\&         "NGYGKRVSFSEFSVHGRGTAGQKIYTQTDRKGAIIGALAVLDTDECMCITGQGKTIRVDV" .
\&         "CAISVLGRGAQGVRVLDIEPSDLVVGLSCVMQG";
.Ve
.PP
.Vb 9
\&      my $fasta_record = new TIGR::FASTArecord $header1, $data1;
\&      if ( defined ( $fasta_record ) ) {
\&         print STDOUT "Sequence " . $fasta_record->getIdentifier() . " is " .
\&                      $fasta_record->size() . " residues.\en";
\&         print STDOUT $fasta_record->toString();
\&      }
\&      else {
\&         die "Invalid FASTA record 1";
\&      }
.Ve
.PP
.Vb 17
\&      # but this header is also valid.
\&      my $header2 = ">ORF00001 The first ORF in the series";
\&      my $data2 = 
\&         "MEEISTPEGGVLVPISIETEVKRAYIDYSMSVIVSRALPDVRDGLKPVHRRILYAMEEKG" .
\&         "LRFSGPTRKCAKIVGDVLGSFHPHGDASVYDALVRLGQDFSLRYPVIHPQGNFGTIGGDP" .
\&         "PAAYRYTEAKMARIAESMVEDIKKETVSFVPNFDDSDVEPTVLPGRFPFLLANGSSGIAV" .
\&         "GMTTNMPPHNLREIAAAISAYIENPNLSIQELCDCINGPDFPTGGIIFGKNGIRQSYETG" .
\&         "RGKIVVRARFTIETDSKGRDTIIFTEVPYQVNTTMLVMRIGELARAKVIEGIANVNDETS" .
\&         "DRTGLRIVVELKKGTPAQVVLNHLFAKTPLQSSFNVINLALVEGRPRMLTLKDLVRYFVE" .
\&         "HRVDVVTRRAHFELRKAQERIHLVRALIRALDAIDKIITLIRHSQNTELAKQRLREQFDF" .
\&         "DNVQAQAIVDMQMKRLTGLEVESLRTELKDLTELISSLEELLTSPQKVLGVVKKETRDIA" .
\&         "DMFGDDRRTDIVSNEIEYLDVEDFIQKEEMVILISHLGYIKRVPVSAYRNQNRGGKGSSS" .
\&         "ANLAAHDFISQIFTASTHDYVMFVTSRGRAYWLKVYGIPESGRANRGSHIKSLLMVATDE" .
\&         "EITAIVSLREFSNKSYVFMATARGVVKKVTTDNFVNAKTRGIIALKLSGGDTLVSAVLVQ" .
\&         "DEDEVMLITRQGKALRMSGREVREMGRNSSGVIGIKLTSEDLVAGVLRVSEQRKVLIMTE" .
\&         "NGYGKRVSFSEFSVHGRGTAGQKIYTQTDRKGAIIGALAVLDTDECMCITGQGKTIRVDV" .
\&         "CAISVLGRGAQGVRVLDIEPSDLVVGLSCVMQG";
.Ve
.PP
.Vb 9
\&      my $fasta_record2 = new TIGR::FASTArecord $header2, $data2;
\&      if ( defined ( $fasta_record2 ) ) {
\&         print STDOUT "Sequence " . $fasta_record2->getIdentifier() . " is " .
\&                      $fasta_record2->size() . " residues.\en";
\&         print STDOUT $fasta_record2->toString();
\&      }
\&      else {
\&         die "Invalid FASTA record 2";
\&      }
.Ve
.PP
.Vb 17
\&      # this entry fails; note the 'J' in the second line of data (8th char.)
\&      my $header3 = "ORF00001 The first ORF in the series";
\&      my $data3 = 
\&         "MEEISTPEGGVLVPISIETEVKRAYIDYSMSVIVSRALPDVRDGLKPVHRRILYAMEEKG" .
\&         "LRFSGPTJKCAKIVGDVLGSFHPHGDASVYDALVRLGQDFSLRYPVIHPQGNFGTIGGDP" .
\&         "PAAYRYTEAKMARIAESMVEDIKKETVSFVPNFDDSDVEPTVLPGRFPFLLANGSSGIAV" .
\&         "GMTTNMPPHNLREIAAAISAYIENPNLSIQELCDCINGPDFPTGGIIFGKNGIRQSYETG" .
\&         "RGKIVVRARFTIETDSKGRDTIIFTEVPYQVNTTMLVMRIGELARAKVIEGIANVNDETS" .
\&         "DRTGLRIVVELKKGTPAQVVLNHLFAKTPLQSSFNVINLALVEGRPRMLTLKDLVRYFVE" .
\&         "HRVDVVTRRAHFELRKAQERIHLVRALIRALDAIDKIITLIRHSQNTELAKQRLREQFDF" .
\&         "DNVQAQAIVDMQMKRLTGLEVESLRTELKDLTELISSLEELLTSPQKVLGVVKKETRDIA" .
\&         "DMFGDDRRTDIVSNEIEYLDVEDFIQKEEMVILISHLGYIKRVPVSAYRNQNRGGKGSSS" .
\&         "ANLAAHDFISQIFTASTHDYVMFVTSRGRAYWLKVYGIPESGRANRGSHIKSLLMVATDE" .
\&         "EITAIVSLREFSNKSYVFMATARGVVKKVTTDNFVNAKTRGIIALKLSGGDTLVSAVLVQ" .
\&         "DEDEVMLITRQGKALRMSGREVREMGRNSSGVIGIKLTSEDLVAGVLRVSEQRKVLIMTE" .
\&         "NGYGKRVSFSEFSVHGRGTAGQKIYTQTDRKGAIIGALAVLDTDECMCITGQGKTIRVDV" .
\&         "CAISVLGRGAQGVRVLDIEPSDLVVGLSCVMQG";
.Ve
.PP
.Vb 10
\&      my $fasta_record3 = new TIGR::FASTArecord $header3, $data3;
\&      if ( defined ( $fasta_record3 ) ) {
\&         print STDOUT "Sequence " . $fasta_record3->getIdentifier() . " is " .
\&                      $fasta_record3->size() . " residues.\en";
\&         print STDOUT $fasta_record3->toString();
\&      }
\&      else {
\&         die "Invalid FASTA record 3";
\&      }
\&   }
.Ve
