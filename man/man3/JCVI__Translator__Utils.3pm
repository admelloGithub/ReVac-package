.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "JCVI::Translator::Utils 3"
.TH JCVI::Translator::Utils 3 "2008-09-11" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
JCVI::Translator::Utils \- Utilities that requrie a translation table
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use JCVI::Translator::Utils;
.Ve
.PP
.Vb 3
\&    # Same constructor as JCVI::Translator
\&    my $utils = new JCVI::Translator::Utils();
\&    my $utils = custom JCVI::Translator( \e$custom_table );
.Ve
.PP
.Vb 3
\&    my $codons = $utils->codons( $residue );
\&    my $regex  = $utils->regex( $residue );
\&    my $indices = $utils->find( $residue );
.Ve
.PP
.Vb 2
\&    my $orf = $utils->getORF( $seq_ref );
\&    my $cds = $utils->getCDS( $seq_ref );
.Ve
.PP
.Vb 1
\&    my $frames = $utils->nonstop( $seq_ref );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
See JCVI::Translator for more info. Utils contains utilites that require
knowledge of the translation table.
.SH "METHODS"
.IX Header "METHODS"
.Sh "codons"
.IX Subsection "codons"
.Vb 2
\&    my $codon_array = $translator->codons( $residue);
\&    my $codon_array = $translator->codons( $residue, \e%params );
.Ve
.PP
Returns a list of codons for a particular residue or start codon. In addition
to the one-letter codes for amino acids, the following are valid inputs for the
residue:
.PP
.Vb 5
\&    start:  Start codons (you may also use "+" which is what the translator
\&            uses as the 1-letter code for start codons)
\&    stop:   Stop codons (you may also use "*" which is the 1-letter code)
\&    lower:  Start or stop codons, depending up on strand
\&    upper:  Start or stop codons, depending up on strand
.Ve
.PP
\&\*(L"lower\*(R" and \*(L"upper\*(R" match the respective ends of a \s-1CDS\s0 for a given strand (i.e.
on the positive strand, lower matches the start, and upper matches them stop).
Valid options for the params hash are:
.PP
.Vb 1
\&    strand:     1 or -1; default = 1
.Ve
.Sh "regex"
.IX Subsection "regex"
.Vb 2
\&    my $regex = $translator->regex( $residue );
\&    my $regex = $translator->regex( $residue, \e%params );
.Ve
.PP
Returns a regular expression matching codons for a particular amino acid
residue. In addition to the one-letter codes for amino acids, the following are
valid inputs for the residue:
.PP
.Vb 5
\&    start:  Start codons (you may also use "+" which is what the translator
\&            uses as the 1-letter code for start codons)
\&    stop:   Stop codons (you may also use "*" which is the 1 letter code)
\&    lower:  Start or stop codons, depending up on strand
\&    upper:  Start or stop codons, depending up on strand
.Ve
.PP
\&\*(L"lower\*(R" and \*(L"upper\*(R" match the respective ends of a \s-1CDS\s0 for a given strand (i.e.
on the positive strand, lower matches the start, and upper matches the stop).
Valid options for the params hash are:
.PP
.Vb 1
\&    strand: 1 or -1; default = 1
.Ve
.Sh "find"
.IX Subsection "find"
.Vb 2
\&    my $locations = $translator->find( $seq_ref, $residue );
\&    my $locations = $translator->find( $seq_ref, $residue, \e%params );
.Ve
.PP
Find the indexes of a given residue in a sequence. In addition to the
one-letter codes for amino acids, the following are valid inputs for the
residue:
.PP
.Vb 5
\&    start:  Start codons (you may also use "+" which is what the translator
\&            uses as the 1-letter code for start codons)
\&    stop:   Stop codons (you may also use "*" which is the 1 letter code)
\&    lower:  Start or stop codons, depending up on strand
\&    upper:  Start or stop codons, depending up on strand
.Ve
.PP
\&\*(L"lower\*(R" and \*(L"upper\*(R" match the respective ends of a \s-1CDS\s0 for a given strand (i.e.
on the positive strand, lower matches the start, and upper matches the stop).
Valid options for the params hash are:
.PP
.Vb 1
\&    strand:     1 or -1; default = 1
.Ve
.Sh "getORF"
.IX Subsection "getORF"
.Vb 2
\&    my $orf_hash = $translator->getORF( $seq_ref );
\&    my $orf_hash = $translator->getORF( $seq_ref, \e%params );
.Ve
.PP
This will get the longest region between stops and return the strand, lower and
upper bounds, inclusive. Valid options for the params hash are:
.PP
.Vb 4
\&    strand:     0, 1 or -1; default = 0 (meaning search both strands)
\&    lower:      integer between 0 and length; default = 0
\&    upper:      integer between 0 and length; default = length
\&    sanitized:  0 or 1; default = 0
.Ve
.PP
Lower and upper are used to specify bounds between which you are searching.
Suppose the following was the longest \s-1ORF:\s0
.PP
.Vb 4
\& 0 1 2 3 4 5 6 7 8 9 10
\&  T A A A T C T A A G
\&  *****       *****
\&        <--------->
.Ve
.PP
This will return:
.PP
.Vb 5
\&    {
\&        strand => 1,
\&        lower  => 3,
\&        upper  => 9
\&    }
.Ve
.PP
You can also specify which strand you are looking for the \s-1ORF\s0 to be on.
.PP
For ORFs starting at the very beginning of the strand or trailing off the end,
but not in phase with the start or ends, this method will cut at the last
complete codon. For example, if the following was the longest \s-1ORF:\s0
.PP
.Vb 4
\&    0 1 2 3 4 5 6 7 8 9 10
\&     A C G T A G T T T A
\&                   *****
\&       <--------------->
.Ve
.PP
getORF will return:
.PP
.Vb 5
\&    {
\&        strand => 1,
\&        lower  => 1,
\&        upper  => 10
\&    }
.Ve
.PP
The distance between lower and upper will always be a multiple of 3. This is to
make it clear which frame the \s-1ORF\s0 is in. The resulting hash may be passed to
the translate method.
.PP
Example:
.PP
.Vb 9
\&    my $orf_ref = $translator->getORF( \e'TAGAAATAG' );
\&    my $orf_ref = $translator->getORF( \e$seq, { strand => -1 } );
\&    my $orf_ref = $translator->getORF(
\&        \e$seq,
\&        {
\&            lower => $lower,
\&            upper => $upper
\&        }
\&    );
.Ve
.Sh "getCDS"
.IX Subsection "getCDS"
.Vb 2
\&    my $cds_ref = $translator->getCDS( $seq_ref );
\&    my $cds_ref = $translator->getCDS( $seq_ref, \e%params );
.Ve
.PP
This will return the strand and boundaries of the longest \s-1CDS\s0.
.PP
.Vb 4
\& 0 1 2 3 4 5 6 7 8 9 10
\&  A T G A A A T A A G
\&  >>>>>       *****
\&  <--------------->
.Ve
.PP
Will return:
.PP
.Vb 5
\&    {
\&        strand => 1,
\&        lower  => 0,
\&        upper  => 9
\&    }
.Ve
.PP
Valid options for the params hash are:
.PP
.Vb 5
\&    strand:     0, 1 or -1; default = 0 (meaning search both strands)
\&    lower:      integer between 0 and length; default = 0
\&    upper:      integer between 0 and length; default = length
\&    strict:     0, 1 or 2;  default = 1
\&    sanitized:  0 or 1; default = 0
.Ve
.PP
Strict controls how strictly getCDS functions. There are 3 levels of
strictness, enumerated 0, 1 and 2. 2 is the most strict, and in that mode, a
region will only be considered a \s-1CDS\s0 if both the start and stop is found. In
strict level 1, if a start is found, but no stop is present before the end of
the sequence, the \s-1CDS\s0 will run until the end of the sequence. Strict level 0
assumes that start codon is present in each frame just before the start of the
molecule. Level 1 is a pretty safe bet, so that is the default.
.PP
Example:
.PP
.Vb 3
\&    my $cds_ref = $translator->getCDS(\e'ATGAAATAG');
\&    my $cds_ref = $translator->getCDS(\e$seq, { strand => -1 } );
\&    my $cds_ref = $translator->getCDS(\e$seq, { strict => 2 } );
.Ve
.Sh "nonstop"
.IX Subsection "nonstop"
.Vb 2
\&    my $frames = $translator->nonstop( $seq_ref );
\&    my $frames = $translator->nonstop( $seq_ref, \e%params );
.Ve
.PP
Returns the frames that contain no stop codons for the sequence. Frames are
numbered \-3, \-2, \-1, 1, 2 and 3.
.PP
.Vb 7
\&     3   ---->
\&     2  ----->
\&     1 ------>
\&       -------
\&    -1 <------
\&    -2 <-----
\&    -3 <----
.Ve
.PP
Valid options for the params hash are:
.PP
.Vb 2
\&    strand:     0, 1 or -1; default = 0 (meaning search both strands)
\&    sanitized:  0 or 1; default = 0
.Ve
.PP
Example:
.PP
.Vb 3
\&    my $frames = $translator->nonstop(\e'TACGTTGGTTAAGTT'); # [ 2, 3, -1, -3 ]
\&    my $frames = $translator->nonstop(\e$seq, { strand => 1 }  ); # [ 2, 3 ]
\&    my $frames = $translator->nonstop(\e$seq, { strand => -1 } ); # [ -1, -3 ]
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Kevin Galinsky, <kgalinsk@jcvi.org>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2008\-2009 J. Craig Venter Institute, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
