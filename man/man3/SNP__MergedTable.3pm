.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SNP::MergedTable 3"
.TH SNP::MergedTable 3 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "Module"
.IX Header "Module"
SNP::MergedTable.pm \- Module for writing/parsing \s-1SNP\s0 MergedTable files
.SH "Description"
.IX Header "Description"
This module is used for writing/parsing a format used with \s-1SNP\s0 descriptions, MergedTable. The files is tab delimited and has the following columns:
.PP
.Vb 20
\& molecule:        An identifier for the molecule.
\& refpos:          Position of SNP in reference
\& syn?:            SYN or NSYN if within gene, 'NA' otherwise
\& refbase:         The base in the reference
\& <queries>:       Variable number of columns, one for each query. The value will be the base of the SNP in the query. 
\&                  If the region was not found in the query, the string 'No Hit' will be here.
\& gene_name:       If the SNP is with a gene, the name of that gene, otherwise the string 'None'
\& product:         The common name of the gene this SNP is within. The string "intergenic" if not in a gene
\& gene_start:      Start of the gene.
\& gene_stop:       Stop of the gene.
\& gene_length:     Length of gene if SNP is within gene.
\& snps_per_gene:   The number of SNPs in this gene.
\& pos_in_gene:     Position of SNP within gene.
\& ref_codon:       The reference codon
\& ref_aa:          The reference amino acid.
\& query_codon:     The query codon (if multiple, separated by /, example ACT/AGT)
\& query_aa:        The query amino acid (if multiple, separatedy by /, example T/S)
\& <num_hits>:      A column for each query, listing the number of hits from blast results [used in snp-verify]. Optional.
\& properties:      Column of key-value pairs in the format of <key>=<value> (ex. verified=false) separated by
\&                  semi-colons. Optional.
.Ve
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\& my $mtable = SNP::MergedTable::parse( "/path/to/merged.table" );
.Ve
.PP
.Vb 2
\& # Need to write this part yet.
\& $mtable->filter( <STUFF HERE> );
.Ve
.PP
.Vb 1
\& $mtable->print_to_fh( $fh );
.Ve
.PP
.Vb 1
\& or
.Ve
.PP
.Vb 3
\& my $mtable = new SNP::MergedTable();
\& $mtable->add_row( new SNP::MergedTable::Row( $row ) );
\& $mtable->print_to_file( "/path/to/output/merged.table" );
.Ve
.SH "Author"
.IX Header "Author"
Kevin Galens (kgalens@gmail.com)
.SH "Methods"
.IX Header "Methods"
.Sh "Class Methods"
.IX Subsection "Class Methods"
\fISNP::MergedTable::parse( \f(CI$file_path\fI )\fR
.IX Subsection "SNP::MergedTable::parse( $file_path )"
.RS 2
.Sp
.RS 3
\&\fBDescription:\fR Creates a MergedTable object from a file path.
.Sp
\&\fBParameters:\fR \f(CW$file_path:\fR path to the merged table file to parse
.Sp
\&\fBReturns:\fR a SNP::MergedTable object reference
.RE
.RE
.RS 2
.RE
.Sh "Instance Methods"
.IX Subsection "Instance Methods"
\fI$merged_table\->missing_query_bases_nohit( \f(CI$var\fI )\fR
.IX Subsection "$merged_table->missing_query_bases_nohit( $var )"
.Sp
.RS 3
\&\fBDescription:\fR Sets whether a missing query_base should have a value of 'No Hit'. By
 default will use the reference base if missing. If no parameter is given, will return
 current value set for the parameter.
.Sp
\&\fBParameters:\fR \f(CW$var:\fR A non-zero value indicates 'No Hit' value should be used for missing query bases.
.Sp
\&\fBReturns:\fR The value for the missing_query_bases_nohit param
.RE
.PP
\fI$merged_table\->include_num_hits( \f(CI$var\fI )\fR
.IX Subsection "$merged_table->include_num_hits( $var )"
.Sp
.RS 3
\&\fBDescription:\fR If set to non\-zero, a num_hit column for each query will be included in 
 the output file. If set to zero, these columns will be omitted.
.Sp
\&\fBParameters:\fR \f(CW$var:\fR A non-zero value indicates num_hit columns should be included in the output.
.Sp
\&\fBReturns:\fR The value for the include_num_hits parameter.
.RE
.PP
\fI$merged_table\->queries( [$queries] )\fR
.IX Subsection "$merged_table->queries( [$queries] )"
.Sp
.RS 3
\&\fBDescription:\fR Used to set the queries. If an array ref of queries is provided,
 all queries previously set will be removed and the new set added. If no parameters 
 are passed in, will return the current list of queries.
.Sp
\&\fBParameters:\fR \f(CW$queries:\fR used to set the query list.
.Sp
\&\fBReturns:\fR Array of query names
.RE
.PP
\fI$merged_table\->add_query( \f(CI$query\fI )\fR
.IX Subsection "$merged_table->add_query( $query )"
.Sp
.RS 3
\&\fBDescription:\fR Will add a query to this table.
.Sp
\&\fBParameters:\fR \f(CW$query:\fR the name of the query.
.Sp
\&\fBReturns:\fR 1 on success
.RE
.PP
\fI$merged_table\->num_queries( )\fR
.IX Subsection "$merged_table->num_queries( )"
.Sp
.RS 3
\&\fBDescription:\fR Returns the total number of queries added to this table.
.Sp
\&\fBParameters:\fR None
.Sp
\&\fBReturns:\fR Number of queries.
.RE
.PP
\fI$merged_table\->query_exists( \f(CI$query_name\fI )\fR
.IX Subsection "$merged_table->query_exists( $query_name )"
.Sp
.RS 3
\&\fBDescription:\fR Returns true if the query exists in this table.
.Sp
\&\fBParameters:\fR \f(CW$query:\fR query name
.Sp
\&\fBReturns:\fR Will return the number of times this query has been added to the file.
.RE
.PP
\fI$merged_table\->add_row( \f(CI$row\fI, \f(CI$queries\fI )\fR
.IX Subsection "$merged_table->add_row( $row, $queries )"
.Sp
.RS 3
\&\fBDescription:\fR Will accept a string representation of a row or a SNP::MergedTable::Row object
 and store it as a row in the table. 
.Sp
.Vb 4
\& *NOTE: If a string representation of a row is passed in, the current list of queries is
\& used to determine the column headers unless specified with the $queries parameter. 
\& If a row string is passed in before the queries are set and the $queries parameter is not set,
\& this method will fail.
.Ve
.Sp
\&\fBParameters:\fR \f(CW$row:\fR Either a string representation of a row or a SNP::MergedTable::Row object reference
 \f(CW$queries:\fR array reference of query names used when \f(CW$row\fR is a string. Indicates the headers for the query_bases
  and num_hits columns.
.Sp
\&\fBReturns:\fR Nothing
.RE
.PP
\fI$merged_table\->remove_row( )\fR
.IX Subsection "$merged_table->remove_row( )"
.Sp
.RS 3
\&\fBDescription:\fR Will remove a row (or rows) if they exist. If row specified does
    not exist, program will die. 
.Sp
\&\fBParameters:\fR \f(CW$row:\fR a SNP::MergedTable::Row object.
.Sp
\&\fBReturns:\fR The number of rows removed from the table (should only ever be 1).
.RE
.PP
\fI$merged_table\->remove_row_by_position( )\fR
.IX Subsection "$merged_table->remove_row_by_position( )"
.Sp
.RS 3
\&\fBDescription:\fR Will remove a row (or rows) if they exist. If row specified does
    not exist, program will die. If a gene name is provided, only the \s-1SNP\s0 located
    on that specified gene will be removed. If no gene name is provided, multiple
    rows might be removed if multiple SNPs occur at the specified refpos.
.Sp
\&\fBParameters:\fR \f(CW$molecule:\fR Molecule name on which the \s-1SNP\s0 is located.
               \f(CW$refpos:\fR The position on the molecule.
               \f(CW$gene:\fR [Optional] The gene name on which the \s-1SNP\s0 is located.
.Sp
\&\fBReturns:\fR The number of rows removed from the table.
.RE
.PP
\fI$merged_table\->row_exists( )\fR
.IX Subsection "$merged_table->row_exists( )"
.Sp
.RS 3
\&\fBDescription:\fR Checks to see if a specified row exists. If gene name is provided
    will specifically look for a \s-1SNP\s0 stored under that gene name. If no gene name 
    is provided, will return non-zero if any \s-1SNP\s0 is present at that refpos.
.Sp
\&\fBParameters:\fR \f(CW$molecule:\fR Molecule name on which the \s-1SNP\s0 is located.
               \f(CW$refpos:\fR The position on the molecule.
               \f(CW$gene:\fR [Optional] The gene name on which the \s-1SNP\s0 is located.
.Sp
\&\fBReturns:\fR Non-zero if a row exists describing the \s-1SNP\s0.
.RE
.PP
\fI$merged_table\->get_rows( )\fR
.IX Subsection "$merged_table->get_rows( )"
.Sp
.RS 3
\&\fBDescription:\fR Retrieves the rows for the table.
.Sp
\&\fBParameters:\fR None
.Sp
\&\fBReturns:\fR An array of rows, sorted by molecule name then reference \s-1SNP\s0 position
.RE
.PP
\fI$merged_table\->get_row_by_position( \f(CI$molecule\fI, \f(CI$refpos\fI )\fR
.IX Subsection "$merged_table->get_row_by_position( $molecule, $refpos )"
.Sp
.RS 3
\&\fBDescription:\fR Retrieve a row by the \s-1SNP\s0 position on a reference molecule
.Sp
\&\fBParameters:\fR \f(CW$molecule:\fR name of the molecule on which the snp is located
 \f(CW$refpos:\fR position on that molecule.
.Sp
\&\fBReturns:\fR Returns a SNP::MergedTable::Row object reference is row exists for a \s-1SNP\s0
 at that position, otherwise will return undef.
.RE
.PP
\fI$merged_table\->get_header( )\fR
.IX Subsection "$merged_table->get_header( )"
.Sp
.RS 3
\&\fBDescription:\fR Retrieve header text. Will die if no queries have been set.
.Sp
\&\fBParameters:\fR None
.Sp
\&\fBReturns:\fR An array containing the names for the columns
.RE
.PP
\fI$merged_table\->filter( \f(CI$fh\fI )\fR
.IX Subsection "$merged_table->filter( $fh )"
.Sp
.RS 3
\&\fBDescription:\fR Will filter the merged table file. Will only work with current
    rows. Any future rows added will not be filtered.
.Sp
\&\fBParameters:\fR \f(CW$filter_name:\fR the name of the filter. Must be valid
.Sp
\&\fBReturns:\fR Nothing.
.RE
.PP
\fI$merged_table\->print_to_fh( \f(CI$fh\fI )\fR
.IX Subsection "$merged_table->print_to_fh( $fh )"
.Sp
.RS 3
\&\fBDescription:\fR Will write Merged Table to the passed in file handle
.Sp
\&\fBParameters:\fR \f(CW$fh:\fR File handle
.Sp
\&\fBReturns:\fR None
.RE
.PP
\fI$merged_table\->print_to_file( \f(CI$file_path\fI )\fR
.IX Subsection "$merged_table->print_to_file( $file_path )"
.Sp
.RS 3
\&\fBDescription:\fR Will write Merged Table to the passed in file
.Sp
\&\fBParameters:\fR \f(CW$file_path:\fR path to output file
.Sp
\&\fBReturns:\fR None
.RE
