.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TIGR::FASTAreader 3"
.TH TIGR::FASTAreader 3 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
TIGR::FASTAreader \- TIGR::FASTAreader class for parsing and navigating
FASTA format files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&   use TIGR::FASTAreader;  
\&   my $obj_instance = new TIGR::FASTAreader ($foundation_obj_ref, 
\&                      $error_array_ref, $fasta_file_name);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module iterates over a \s-1FASTA\s0 formatted database file.  It provides
data extraction and simple analysis routines.  This module utilizes 
acceptance validation of \s-1FASTA\s0 formatted files via the TIGR::FASTAgrammar
module.
.ie n .IP "$obj_instance = new TIGR::FASTAreader ($foundation_object, $error_array_ref\fR, \f(CW$db_file);" 4
.el .IP "$obj_instance = new TIGR::FASTAreader ($foundation_object, \f(CW$error_array_ref\fR, \f(CW$db_file\fR);" 4
.IX Item "$obj_instance = new TIGR::FASTAreader ($foundation_object, $error_array_ref, $db_file);"
This method returns a new instance of a TIGR::FASTAreader object.  It takes
three optional parameters: a TIGR::Foundation object (\f(CW$foundation_object\fR),
a reference to an array for logging user error messages (\f(CW$error_array_ref\fR),
and \s-1FASTA\s0 file (\f(CW$db_file\fR).  The new instance is returned on success.  If
the file supplied cannot be opened or is invalid, this method returns 
undefined. This method also returns undefined if the parameters supplied are 
invalid. Errors in parsing are written to the array at \f(CW$error_array_ref\fR 
and the log file.
.ie n .IP "$result = $obj_instance\fR\->open($file_name, \f(CW$flag);" 4
.el .IP "$result = \f(CW$obj_instance\fR\->open($file_name, \f(CW$flag\fR);" 4
.IX Item "$result = $obj_instance->open($file_name, $flag);"
This method opens a \s-1FASTA\s0 file for reading.  This method also parses the file
for correctness.  The file, \f(CW$file_name\fR, is opened using the \f(CW\*(C`open()\*(C'\fR flags
specified by \f(CW$flag\fR.  On success, this method returns 1.  If the file cannot
be opened or parsing fails, this method returns undefined.
.ie n .IP "$result = $obj_instance\fR\->\fIclose();" 4
.el .IP "$result = \f(CW$obj_instance\fR\->\fIclose()\fR;" 4
.IX Item "$result = $obj_instance->close();"
This method closes the object file stream and resets all internal data
structures.  The result of the operation is returned.  If the file stream
is closed successfully, this object returns true (1), otherwise false
(undefined).
.ie n .IP "$record_num = $obj_instance\fR\->\fIindex();" 4
.el .IP "$record_num = \f(CW$obj_instance\fR\->\fIindex()\fR;" 4
.IX Item "$record_num = $obj_instance->index();"
This method returns the record number of the active record.  If no record has 
been selected (ie. made active), then this method returns undefined.  If
the active record pointer is before the first record, this method returns
\&'\-1'.
.ie n .IP "$result = $obj_instance\->seekIndex($num);" 4
.el .IP "$result = \f(CW$obj_instance\fR\->seekIndex($num);" 4
.IX Item "$result = $obj_instance->seekIndex($num);"
This method selects a record by record order index.  The \f(CW$num\fR ordered
record is selected.  If \f(CW$num\fR is out of range for the database or not \-1
(indicating to seek one record before the first record), this
function returns undefined and the active record pointer is not changed.
Otherwise, the requested record is made active and the method returns 1.
.ie n .IP "$result = $obj_instance\fR\->\fInext();" 4
.el .IP "$result = \f(CW$obj_instance\fR\->\fInext()\fR;" 4
.IX Item "$result = $obj_instance->next();"
This method selects the next record in numerical order to be the active
record.  It returns the record on success, undefined on failure.  If the active
record is equal to \-1, the first record is selected.
.ie n .IP "$result = $obj_instance\fR\->\fIhasNext();" 4
.el .IP "$result = \f(CW$obj_instance\fR\->\fIhasNext()\fR;" 4
.IX Item "$result = $obj_instance->hasNext();"
This method returns true (1) if there are more elements beyond the
current element.  If not, this method returns false (undefined).
.ie n .IP "$result = $obj_instance\->getRecordByIdentifier($identifier);" 4
.el .IP "$result = \f(CW$obj_instance\fR\->getRecordByIdentifier($identifier);" 4
.IX Item "$result = $obj_instance->getRecordByIdentifier($identifier);"
This method selects a record by record minimal identifier.
If \f(CW$identifier\fR does not exist in the set of records, this function
returns undefined and the previously active record remains active.  Otherwise,
the requested record is made active and the method returns a 
\&\f(CW\*(C`TIGR::FASTArecord\*(C'\fR object representation of the current(active) record.
.ie n .IP "$result = $obj_instance\->seekIdentifier($identifier);" 4
.el .IP "$result = \f(CW$obj_instance\fR\->seekIdentifier($identifier);" 4
.IX Item "$result = $obj_instance->seekIdentifier($identifier);"
This method selects a record by record minimal identifier.
If \f(CW$identifier\fR does not exist in the set of records, this function
returns undefined and the previously active record remains active.  Otherwise,
the requested record is made active and the method returns 1.
.ie n .IP "$record_contents = $obj_instance\fR\->\fIget();" 4
.el .IP "$record_contents = \f(CW$obj_instance\fR\->\fIget()\fR;" 4
.IX Item "$record_contents = $obj_instance->get();"
This method returns a \f(CW\*(C`TIGR::FASTArecord\*(C'\fR object representation of the current
(active) record.  If no defined record is active, this method returns 
undefined.
.ie n .IP "$db_name = $obj_instance\fR\->\fIpath();" 4
.el .IP "$db_name = \f(CW$obj_instance\fR\->\fIpath()\fR;" 4
.IX Item "$db_name = $obj_instance->path();"
This method returns the path to the file used for processing.
.ie n .IP "$cnt = $obj_instance\fR\->\fIcount();" 4
.el .IP "$cnt = \f(CW$obj_instance\fR\->\fIcount()\fR;" 4
.IX Item "$cnt = $obj_instance->count();"
This method returns the number of records in the database file.
.SH "USAGE"
.IX Header "USAGE"
To use this module, load the \f(CW\*(C`TIGR::FASTAreader\*(C'\fR package via the
\&\f(CW\*(C`use\*(C'\fR function.  Then, create a new instance of the object via the
\&\f(CW\*(C`new()\*(C'\fR method, as shown below.  There are several invocations possible
for this method since all parameters to \f(CW\*(C`new()\*(C'\fR are optional.
To access records from the \f(CW\*(C`TIGR::FASTAreader\*(C'\fR instance, the 
\&\f(CW\*(C`TIGR::FASTArecord\*(C'\fR package must be loaded via the \f(CW\*(C`use\*(C'\fR function.
An example script using this module follows.  The \f(CW\*(C`TIGR::Foundation\*(C'\fR
module is included for completeness but does not have to be used.
.Sp
.Vb 1
\&   #!/usr/local/bin/perl -w
.Ve
.Sp
.Vb 8
\&   # This script accepts FASTA files with the '-i' option
\&   # on the command line and validates every one in turn.
\&   # Parse errors are collected to the '@errors_list' array.
\&   # This program concatenates all of the records together to 
\&   # one output file specified with the '-o' option.
\&   # NOTE: The '-i' option must be specified before every input file.
\&   # NOTE: The 'TIGR::FASTAwriter' module is intended for writing 
\&   #       FASTA records.
.Ve
.Sp
.Vb 3
\&   use strict;
\&   use TIGR::FASTAreader;
\&   use TIGR::FASTArecord;
.Ve
.Sp
.Vb 6
\&   MAIN:
\&   {
\&      my $tf_object = new TIGR::Foundation;
\&      my @errors_list = ();
\&      my @input_files = ();
\&      my $output_file = undef;
.Ve
.Sp
.Vb 6
\&      # Capture the return code from the TIGR::Foundation method
\&      my $result = $tf_object->TIGR_GetOptions('i=s' => \e@input_files,
\&                                               'o=s' => \e$output_file);
\&      if ( $result != 1 ) {
\&         $tf_object->bail("Invalid command line options.");
\&      }
.Ve
.Sp
.Vb 3
\&      # Create a TIGR::FASTAreader instance using TIGR::Foundation and
\&      # an error message list.
\&      my $fasta_reader = new TIGR::FASTAreader $tf_object, \e@errors_list;
.Ve
.Sp
.Vb 4
\&      if ( !(  defined ( $output_file ) &&
\&               open OUTFILE, ">$output_file" ) ) {
\&         $tf_object->bail("Cannot open output file for writing.");
\&      }
.Ve
.Sp
.Vb 3
\&      foreach my $in_file ( @input_files ) {
\&         $fasta_reader->open($in_file) or
\&            $tf_object->logLocal("Cannot open or read file $in_file", 2);
.Ve
.Sp
.Vb 6
\&         if ( scalar(@errors_list) > 0 ) { # are there parse errors?
\&            while ( @errors_list ) { # get the messages from the list
\&               my $message = shift @errors_list; 
\&               print STDERR $message, "\en";
\&            }
\&         }
.Ve
.Sp
.Vb 6
\&         while ( $fasta_reader->hasNext() ) {
\&            # print each record to OUTFILE
\&            print OUTFILE $fasta_reader->next()->toString();
\&         }
\&      }
\&   }
.Ve
