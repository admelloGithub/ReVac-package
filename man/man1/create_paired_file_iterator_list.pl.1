.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CREATE_PAIRED_FILE_ITERATOR_LIST 1"
.TH CREATE_PAIRED_FILE_ITERATOR_LIST 1 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
create_file_iterator_list.pl \- generates list file from various paired input sources of filenames.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1USAGE:\s0 create_file_iterator_list.pl 
        \-\-input_pairs_list
        \-\-input_file_list_1
        \-\-input_file_list_2
        \-\-input_file_1
        \-\-input_file_2
        \-\-all_vs_all=[0,1]
        \-\-input_mapping_file=/path/to/file_names.map
        \-\-output_iter_list=/path/to/output
        [\-\-checksum_filenames=1
        \-\-log=/path/to/some.log
        \-\-debug=4 ]
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-input_pairs_list,\-p\fR
    The full path to a list of file pairs. When using this option, will ignore all other 
    input options. Can be a comma separated list of lists. 
.PP
\&\fB\-\-input_file_list_1,\-l1\fR 
    a plain text file containing the full paths to any number of files, one per line.  
    this can also be a comma-separated list of input file lists.
.PP
\&\fB\-\-input_file_list_2,\-l2\fR 
    a plain text file containing the full paths to any number of files, one per line.  
    this can also be a comma-separated list of input file lists.
.PP
\&\fB\-\-input_file_1,\-f1\fR 
    the full path to an input file. this can also be a comma-separated list of 
    input files.
.PP
\&\fB\-\-input_file_2,\-f2\fR 
    the full path to an input file. this can also be a comma-separated list of 
    input files.
.PP
\&\fB\-\-input_mapping_file,\-im\fR
    If input file lists are used (\-\-input_file_list_1 and \-\-input_file_list_2), and they
    are not in order the order specified in the input_mapping_file will be used. This file
    should be a two column tab file with input 1 in the first column and input 2 in the 
    second. Will look at file names only (no paths). Consequently, this will only work if 
    you have unique file names. If there are different numbers of files in the two input lists
    will fail. Will also fail if some files from the input list cannot be found in the mapping
    file.
.PP
\&\fB\-\-all_vs_all,\-a\fR
    Possible values: 0 or non\-zero.
    When using many vs many input files, these can be handled two ways. The first way is to take all combination
    of input files. The other way is to assume take them in the order they were provided. For example, the 
    first file of input_list_1 will be paired with the first file of input_list_2. Then the second files
    of the lists would be paired and so on. This program will throw an error if the number of input files for
    each set of inputs does not match and \-\-all_vs_all = 0
.PP
\&\fB\-\-checksum_filenames\fR 
    use checksums instead of the basename as the iterator name. The checksum will be based on the full path to the file.
.PP
\&\fB\-\-log\fR 
    optional.  path to a log file the script should create.  will be overwritten if
    already exists.
.PP
\&\fB\-\-debug\fR 
    optional.  the debug level for the logger (an integer)
.PP
\&\fB\-\-help,\-h\fR 
    This help message/documentation.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 10
\&    This script is used to accept a selection of paired inputs. This is to allow
\&    on-the-fly creation of n vs m iterations. If both inputs are a single
\&    file, there will only be one line in the output iterator list. If either (but 
\&    not both) of the inputs is multiple files, this script will generate n (where n
\&    is the number of files ) lines in the output iterator list. If both inputs contain
\&    multiple files, the script will look at the all_vs_all flag to determine how to 
\&    handle the input. If the value of the option is 1, there will be n * m output lines.
\&    If the value of all_vs_all = 0, then the script will assume that the inputs are ordered
\&    and the inputs should contain the same number of files. There will be n = m lines in 
\&    the output list.
.Ve
.PP
.Vb 8
\&    Alternatively, if the two sets of inputs used are not in the correct order and the 
\&    input_mapping_file option is specified, the pairings will be made according to the
\&    mapping file. The mapping file should contain file names only (no path information) in
\&    two columns, on representing each input. If this option is used, there must be values 
\&    specified in the --input_file_[1,2] and/or --input_file_list_[1,2] options and they 
\&    must contain the same number of files. Also, the --all_vs_all option is ignored in this
\&    case. If some input files could not be found in the mapping file, the script will die.
\&    If file names are not unique, the script will also die.
.Ve
.PP
.Vb 3
\&    The --input_pairs_list can also be used. This is expected to be a 2 column list of paired
\&    input files. If this option is used, all other input options will be ignored. The output list
\&    will contain the same number of lines as the --input_pairs_list file does.
.Ve
.SH "OUTPUT"
.IX Header "OUTPUT"
.Vb 1
\&    Will print an output tab file (iterator list file) with the following columns:
.Ve
.PP
.Vb 1
\&    $;I_FILE_BASE_1$;   $;I_FILE_NAME_1$;       $;I_FILE_PATH_1$;       $;I_FILE_EXT_1$;        $;I_DIR_1$;  $;I_FILE_BASE_2$;  $;I_FILE_NAME_2$;       $;I_FILE_PATH_2$;       $;I_FILE_EXT_2$;        $;I_DIR_2$;
.Ve
.PP
.Vb 2
\&    The number of lines in the output files will depend on the nature of the input. See DESCRIPTION 
\&    for more details.
.Ve
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Kevin Galens
\&    kevingalens@gmail.com
.Ve
