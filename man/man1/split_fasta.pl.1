.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SPLIT_FASTA 1"
.TH SPLIT_FASTA 1 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
split_fasta.pl \- split a single\-sequence FASTA file into separate, optionally overlapping, portions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&    USAGE: split_fasta.pl 
\&                --input_file=/path/to/some_file.fsa 
\&                --output_dir=/path/to/somedir
\&                --fragment_length=50000
\&              [ --overlap_length=1000 
\&                --file_numbering=incremental|positional
\&                --file_name_root=string
\&                --file_name_suffix=string
\&                --output_list=/path/to/somefile.list
\&                --bsml_map=/path/to/somefile.map.bsml
\&              ]
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-input_file,\-i\fR
    The input multi-fasta file to split.
.PP
\&\fB\-\-output_dir,\-o\fR
    The directory to which the output files will be written.
.PP
\&\fB\-\-fragment_length,\-f\fR
    Given in base pairs, the input sequence will be split into portions of this size (plus optional overhanging sequence)
.PP
\&\fB\-\-overlap_length,\-p\fR
    Given in base pairs, a portion of sequence of this size will be included from the next fragment.
.PP
\&\fB\-\-file_numbering,\-n\fR
    Either 'incremental' or 'positional'.  See the \s-1OUTPUT\s0 section for more information.
.PP
\&\fB\-\-file_name_root,\-r\fR
    Forms the root part of the file name created.  See the \s-1OUTPUT\s0 section for more information.
.PP
\&\fB\-\-file_name_suffix,\-u\fR
    Forms the suffix part of each file name created.  If omitted, defaults to 'fsa'. See the \s-1OUTPUT\s0 section for more information.
.PP
\&\fB\-\-output_list,\-s\fR
    Write a list file containing the paths of each of the regular output files.  This may be useful
    for later scripts that can accept a list as input.
.PP
\&\fB\-\-bsml_map,\-b\fR
    Creates a bsml file containing information which maps each of the fasta files created back
    onto the source file.
.PP
\&\fB\-\-debug,\-d\fR 
    Debug level.  Use a large number to turn on verbose debugging. 
.PP
\&\fB\-\-log,\-l\fR 
    Log file
.PP
\&\fB\-\-help,\-h\fR
    This help message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This script takes a single-sequence \s-1FASTA\s0 file and breaks it into chunks for analysis. This 
is useful for performing analyses on large input files, such as large assemblies, using 
computational tools that do not handle or scale well with large input sequences (such as \s-1AAT\s0).
.PP
Aside from simply splitting the input sequence into user-defined chunks, each chunk can 
optionally include a defined-length overhang from the next sequence. This helps to ensure 
that no features will be missed over the break-point when performing an analysis. Gene 
finders, for example, will miss a gene call if the gene spans the region where the sequence 
was fragmented. 
.SH "INPUT"
.IX Header "INPUT"
The input is defined with \-\-input_file and should be a \s-1FASTA\s0 file with a single sequence.  File 
extensions are ignored.  For example:
.PP
.Vb 4
\&    >gi53791237 Tragulus javanicus p97bcnt gene for p97Bcnt
\&    ACAGGAGAAGAGACTGAAGAGACACGTTCAGGAGAAGAGCAAGAGAAGCCTAAAGAAATGCAAGAAGTTA
\&    AACTCACCAAATCACTTGTTGAAGAAGTCAGGTAACATGACATTCACAAACTTCAAAACTAGTTCTTTAA
\&    AAAGGAACATCTCTCTTTTAATATGTATGCATTATTAATTTATTTACTCATTGGCGTGGAGGAGGAAATG
.Ve
.PP
Whitespace is ignored within the input file.  See the \s-1OUTPUT\s0 section for more on creation of 
output files.
.SH "OUTPUT"
.IX Header "OUTPUT"
As the input file is fragmented, multiple output files (one for each fragment) need to be written.  
How these files are named depends on the value of the optional \-\-file_numbering and \-\-file_name_root 
options.  If \-\-file_name_root is not given, the first part of the file name will simply be the 
original file name.  The \-\-file_numbering option will control the part of each output file name
after the root portion.  The default value is 'incremental'.  Examples are in order:
.PP
.Vb 5
\&    original file name: somefile.fsa
\&    --file_numbering='incremental'
\&    --file_name_root was NOT PASSED
\&    --file_name_suffix='fsa'
\&    --fragment_length=50000
.Ve
.PP
.Vb 4
\&    somefile.fsa.1.fsa
\&    somefile.fsa.2.fsa
\&    somefile.fsa.3.fsa
\&    ...
.Ve
.PP
But that's probably not what you want, since .fsa is now in the file name twice.  It would be better
to do it like this:
.PP
.Vb 5
\&    original file name: somefile.fsa
\&    --file_numbering='incremental'
\&    --file_name_root='somefile'
\&    --file_name_suffix='fsa'
\&    --fragment_length=50000
.Ve
.PP
.Vb 4
\&    somefile.1.fsa
\&    somefile.2.fsa
\&    somefile.3.fsa
\&    ...
.Ve
.PP
This may be fine for some applications, but these file names give no positional information
about how the contents of the file relate to the original, larger file.  If this is needed,
use \-\-file_numbering=positional .  More examples:
.PP
If, for example, your large file is called 'somefile.fsa' and
your \-\-fragment_length is set to 50000, the files generated will be named like:
.PP
.Vb 5
\&    original file name: somefile.fsa
\&    --file_numbering='incremental'
\&    --file_name_root='blastres'
\&    --file_name_suffix='fsa'
\&    --fragment_length=50000
.Ve
.PP
.Vb 4
\&    blast_res.0.fsa
\&    blast_res.50000.fsa
\&    blast_res.100000.fsa
\&    ...
.Ve
.PP
The \s-1FASTA\s0 headers for each of the fragment files created will have a slightly modified header.
For each, the \s-1ID\s0 of the file (such as blast_res.0 above) will be inserted as the first element
of the header, followed by a space.
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Joshua Orvis
\&    jorvis@tigr.org
.Ve
