.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ADJUST_BTAB_COORDINATES 1"
.TH ADJUST_BTAB_COORDINATES 1 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
adjust_btab_coordinates.pl \- adjust the positional coordinates within a nap
output alignment file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1USAGE:\s0  adjust_btab_coordinates.pl
            \-\-map_file=/path/to/somemapfile.bsml
            \-\-map_dir=/or/path/to/somedir
            \-\-list_file=/path/to/somefile.list
            \-\-output_dir=/path/to/somedir
          [ \-\-list_file_glob='.*.nap.btab'
            \-\-output_list=/path/to/some.list
            \-\-output_subdir_size=1000
            \-\-output_subdir_prefix=fasta
            \-\-debug=4
            \-\-log=/path/to/somefile.log
          ]
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-map_file,\-m\fR 
    Input \s-1BSML\s0 map file.
.PP
\&\fB\-\-map_dir,\-d\fR 
    Directory of input \s-1BSML\s0 map files.
.PP
\&\fB\-\-list_file,\-i\fR 
    Path to a list of btab files.
.PP
\&\fB\-\-list_file_glob,\-g\fR 
    Use to filter the btab files considered in \-\-list_file.  This should probably
    be given as in the example above.
.PP
\&\fB\-\-output_list,\-u\fR
    Optional.  If passed, will create an output list with the full paths to each of the 
    \s-1BSML\s0 files created by this script.
.PP
\&\fB\-\-output_dir,\-o\fR 
    Directory where output btab files will be written.
.PP
\&\fB\-\-output_subdir_size,\-z\fR
    If defined, this script will create numbered subdirectories in the output directory, each
    containing this many sequences files.  Once this limit is reached, another subdirectory
    is created.
.PP
\&\fB\-\-output_subdir_prefix,\-x\fR
    To be used along with \-\-output_subdir_size, this allows more control of the names of the
    subdirectories created.  Rather than just incrementing numbers (like 10), each subdirectory 
    will be named with this prefix (like prefix10).
.PP
\&\fB\-\-debug,\-d\fR 
    Debug level.  Use a large number to turn on verbose debugging. 
.PP
\&\fB\-\-log,\-l\fR 
    Log file
.PP
\&\fB\-\-help,\-h\fR 
    This help message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Because some sequences are too large to be analyzed directly by some analysis tools, 
it is sometimes necessary to first split those sequences into pieces, perform the 
analysis on each fragment, and then stitch them back together. This last step causes 
problems because any coordinates given in the result file will represent the 
coordinates of the query in the fragment, and not be representative of the coordinates 
of the original sequence.
.PP
The purpose of this script is to read through the results of such an analysis and 
adjust the coordinates to reflect those in the original input file.  This is done using
a set of btab result files along with a mapping file.  Read the \s-1INPUT\s0 section for more
information.
.PP
To use this component, you would most likely have used a splitting component previously
in the pipeline, such as split_fasta, which generates the input maps.
.SH "INPUT"
.IX Header "INPUT"
Two types of input files are required to for this to work.  The first is a list of the
btab result files from an analysis, defined using \-\-list_file.  The list file should
look something like this:
.PP
.Vb 4
\&    /some/path/cpa1.assem.1.0.nap.btab
\&    /some/path/cpa1.assem.1.1.nap.btab
\&    /some/path/cpa1.assem.1.10.nap.btab
\&    /some/path/cpa1.assem.1.11.nap.btab
.Ve
.PP
In this case, a nap analysis was run on 4 sequences, probably named like cpa1.assem.1.0
.PP
If the list file contains more lines than you actually want to consider, you can filter which
will be included by using the \-\-list_file_glob option.
.PP
The \s-1BSML\s0 mapping file, passed with the \-\-map_file option, gives information about how the
coordinates in these files relate to the original non-split file, here named cpa1.assem.1
.PP
If mapping information for the files in your list come from multiple \s-1BSML\s0 maps, you can use
the \-\-map_dir option.  This will load all maps in the specified directory whose names end
in '.map.bsml'
.PP
It is important to note that currently the files must match the naming convention like the
examples above.  This convention is:
.PP
.Vb 1
\&    featid.component.btab
.Ve
.PP
where featid must match the id of some Sequence element in the mapping file.  The \*(L"component\*(R"
portion of the name is currently ignored by this script.  This is how the relationship 
between the fragment and the map is defined.
.PP
Also note this script handles compressed input.  If the input \s-1BSML\s0 files have been gzipped
and end in either the '.gz' or '.gzip' extension, they will be decompressed, modified and
recompressed on the fly.
.SH "OUTPUT"
.IX Header "OUTPUT"
The output alignment files will be written to the directory specified by \-\-output_dir.  You may
specify the output_dir to be the same location as the original files to overwrite them.
.PP
As each alignment file is analyzed, a few changes are made to reflect the coordinates back onto
the non-fragmented sequence.  Specifically, the 7th and 8th columns of the tab-delimited
file are adjusted.  These define the query start and stop coordinates, respectively.
.PP
Note that the file names, such as cpa1.assem.1.0.nap.btab, are not changed, though
they no longer contain information directly concerning the fragment.  This way these
sequences can be loaded as they are \- else we would have to concatenate each of the
fragmented files into one large file before loading, which is not desirable.
.PP
The first column of the output file, however, is stripped of the fragment sequence \s-1ID\s0,
since the coordinates no longer map to that fragmented sequence.  What remains should be
the \s-1ID\s0 of the original, larger sequence.
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Joshua Orvis
\&    jorvis@tigr.org
.Ve
