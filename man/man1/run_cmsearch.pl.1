.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RUN_CMSEARCH 1"
.TH RUN_CMSEARCH 1 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
run_cmsearch.pl \- Takes hmmpfam files as input and runs the hits against
    cmsearch.  Optimization for cmsearch.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1USAGE:\s0 run_cmsearch.pl 
              \-\-input_list=/path/hmmpfam/results.raw.list
              \-\-input_file=/path/hmmpfam/result.raw
              \-\-tmp_dir=/path/to/tmpdir/
              \-\-output_file=/path/to/infernal.raw
              \-\-flanking_seq=50
              \-\-hmm_cm_table=/path/to/some/file.table
              \-\-cmsearch_bin=/path/to/cmsearch
              \-\-cm_dir=/dir/with/covariance/models/
          [   \-\-other_opts=cmsearch options
              \-\-log=/path/to/some/file.log
              \-\-debug= > 2 for verbose
          ]
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-input_list,\-l\fR
    A list of hmmpfam raw output files to be formatted and run with cmsearch
.PP
\&\fB\-\-input_file,\-i\fR
    An input file (hmmpfam) raw output
.PP
\&\fB\-\-tmp_dir,\-t\fR
    Directory to write temporary files.  Will be cleaned up (not yet).
.PP
\&\fB\-\-output_file,\-o\fR
    The output file for cmsearch results to go into.  Will concate all results to this file.
.PP
\&\fB\-\-flanking_seq,\-f\fR
    The number of nucleotides on either side of the hmmpfam hit to parse out of database for 
    cmsearch run. Default: 50.
.PP
\&\fB\-\-hmm_cm_table,\-c\fR
    File containing a lookup for covariance models given an hmm model.  See input section of perldoc
    more specific details on this file.
.PP
\&\fB\-\-cmsearch_bin,\-b\fR
    Path to the cmsearch binary. If not it will be assumed that the binary is in the \s-1PATH\s0.
.PP
\&\fB\-\-cm_dir,\-m\fR
    If you don't feel like making a hmm_cm_table, you can always just put the directory where all
    the covariance models are.  The program will try and guess which covariance model is related to
    each hmm.  Needless to say, hmm_cm_table is a better option.  Turns out, computers are bad
    guessers.
.PP
\&\fB\-\-sequence_list,\-s\fR
    A list of absolute paths to files which contain the input fasta sequence from the \s-1HMMER\s0 search.
    In most cases will be the chromosome/assembly sequence used as input. Used to grab extra flanking
    sequence.
.PP
\&\fB\-\-other_opts,\-e\fR
    Other options to be passed into the cmsearch program.  
    *Note: The \-W option is used by this script and therefore will be parsed out of the other_opts
    string prior to running cmsearch.  This program uses the length of the sequence found by the
    hmmpfam run (plus extraSeq) as the window size.
.PP
\&\fB\-\-debug\fR 
    Debug level.  Use a large number to turn on verbose debugging. 
.PP
\&\fB\-\-log,\-l\fR 
    Log file
.PP
\&\fB\-\-help,\-h\fR
    This help message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The program infernal is used to search covariance models against biological sequences
(see infernal userguide: oryx.ulb.ac.be/infernal.pdf).  More specifically infernal uses
profiles of \s-1RNA\s0 secondary structure for sequence analysis.  The program is computationally
intensive when used with large genomic sequences.  
.PP
Run_cmsearch.pl will take in a set of hmmpfam results as an initial screening to infernal.  
\&\s-1RNA\s0 HMMs can quickly identify regions where \s-1RNA\s0 is located, and these sections can then be further
refined by running this section through cmsearch (infernal).  With a set of HMMs and CMs created from
the same alignments, infernal can be used in a high-throughput manner.
.SH "INPUT"
.IX Header "INPUT"
The main input for run_cmsearch is either a list of hmmpfam raw results or one hmmpfam raw result.
The sequences are then parsed from these hmmpfam results and the database queryed.  The sequence
identifier is taken from the name of the file (which is reliable in the ergatis naming scheme, but
probably could be made more general in the future).  The name of the HMMs are also parsed from these
files.  Important to note that the \s-1HMM\s0 names are not the same as the file names (since hmmpfam can
use a multi-hmm file for searching).  This becomes important in the creation of the hmm_cm_table.
.PP
If a hit was found with an \s-1HMM\s0 file, the related \s-1CM\s0 file will be used to search that portion of the
sequence.  To do this, the program must know which HMMs relate to which CMs.  There are two ways
to provide this information.  This by providing a tab-delimited file with \s-1HMM\s0 name (not file name,
but the name found in the \s-1HMM\s0 header and the one used in hmmpfam output) and \s-1CM\s0 (actual path to file)
on each line.  For example:
.PP
.Vb 3
\&    RF00001.HMM     /usr/local/db/RFAM/CMs/RF00001.cm
\&    RF00002.HMM     /usr/local/db/RFAM/CMs/RF00002.cm
\&    ...
.Ve
.PP
The other option is to provide the program with the directory where all the covariance models are
stored.  The program will then look in that directory for a covariance model that contains the first
word of the \s-1HMM\s0 name (not file name, but actual id name found in hmmpfam results).  
.SH "OUTPUT"
.IX Header "OUTPUT"
The program will create individual fasta files for each hmmpfam hit provided in the input and is 
cleaned up later.  All the cmsearch results (all the stdout from the program run) is written to
output_file.  See infernal userguide: oryx.ulb.ac.be/infernal.pdf for more information on output format.
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Kevin Galens
\&    kgalens@tigr.org
.Ve
