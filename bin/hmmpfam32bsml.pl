#!/usr/bin/env perl

=head1  NAME 

hmmer2bsml.pl - convert hmmpfam or hmmscan raw output to BSML

=head1 SYNOPSIS

USAGE: hmmer2bsml.pl 
        --input=/path/to/somefile.hmmer.raw 
        --output=/path/to/somefile.hmmer.bsml
      [ --search_method=hmmpfam or hmmpfam3
        --query_mol_type=aa
        --query_mol_class=polypeptide
        --model_mol_type=aa
        --model_mol_class=polypeptide
        --fasta_input=/path/to/hmmer/input.fsa
        --gzip_output=1
        --log=/path/to/some.log
        --debug=4 
        --help
      ]

=head1 OPTIONS

B<--input,-i> 
    Input raw alignment file from an hmmpfam or hmmscan search.

B<--output,-o> 
    Output BSML file

B<--search_method,-m> 
    Optional. Search method used with hmmpfam.  Default is 'hmmscan' but others
    include 'hmmsmart', 'hmmpir', etc.

B<--query_mol_type,-qt> 
    Query molecule type (like 'aa' or 'dna'). 

B<--query_mol_class,-qc> 
    Query molecule type (like 'polypeptide' or 'DNA'). 

B<--model_mol_type,-mt> 
    Model molecule type (like 'aa' or 'dna'). 

B<--model_mol_class,-mc> 
    Query molecule type (like 'polypeptide' or 'DNA'). 

B<--fasta_input,-f>
    Optional.  If included, will make a seq data import element and include the 
    defline with the sequences.

B<--gzip_output,-g>
    Optional.  If given a non-zero value, will compress the output and give the output
    file a .gz extension.  If the file already contains one, it won't add another.

B<--debug,-d> 
    Debug level.  Use a large number to turn on verbose debugging. 

B<--log,-l> 
    Log file

B<--help,-h> 
    This help message

=head1   DESCRIPTION

This script is used to convert the raw alignment output from an hmmpfam or hmmscan search into BSML.

=head1 INPUT

The input file passed to this script must be a raw alignment file generated by hmmpfam or hmmscan.
Define the input file using the --input option.

Illegal characters will be removed from the IDs for the query sequence and subject hit
if necessary to create legal XML id names.  For each element, the original, unmodified 
name will be stored in the "title" attribute of the Sequence element.  You should make 
sure that your ids don't begin with a number.  This script will successfully create a 
BSML document regardless of your ID names, but the resulting document may not pass DTD 
validation.

=head1 OUTPUT

The BSML file to be created is defined using the --output option.  If the file already exists
it will be overwritten.

Because the hmmpfam executable is used to perform a variety of searches, including hmmsmart
and hmmtigr, the user may pass a value using --search_method, which will create the
appropriate titles in the BSML Analysis element.  If not passed, the default 'hmmpfam3' is used.

=head1 CONTACT

    Sonia Agrawal
    sagrawal@som.umaryland.edu

=cut

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case no_auto_abbrev);
use Pod::Usage;
use Ergatis::Logger;
use HmmTools;
use BSML::BsmlRepository;
use BSML::BsmlBuilder;
use BSML::BsmlParserTwig;

use Data::Dumper;

my $fasta_input;
my $data;
my %options = ();
my $results = GetOptions (\%options, 
			  'input|i=s',
			  'output|o=s',
			  'search_method|m=s',
			  'query_mol_type|qt=s',
			  'query_mol_class|qc=s',
			  'model_mol_type|mt=s',
			  'model_mol_class|mc=s',
			  'fasta_input|f=s',
			  'gzip_output|g=s',
			  'log|l=s',
			  'debug=s',
			  'help|h') || pod2usage();

my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename();
my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile,
				 'LOG_LEVEL'=>$options{'debug'});
$logger = $logger->get_logger();

# display documentation
if( $options{'help'} ){
    pod2usage( {-exitval=>0, -verbose => 2, -output => \*STDOUT} );
}

## make sure all passed options are peachy
&check_parameters(\%options);

## we want a new doc
my $doc = new BSML::BsmlBuilder();

## open the input file for parsing
open (my $ifh, $options{'input'}) || $logger->logdie("can't open input file for reading");

if ($options{'search_method'} eq 'hmmpfam') {
    $data = &read_hmmer2_output($options{'input'});
} elsif ($options{'search_method'} eq 'hmmpfam3') {
    $data = &read_hmmer3_output($options{'input'});
}

## check that these were successfully parsed
unless($data->{'info'}->{'hmm_file'})      { $logger->logdie("HMM file definition not found in input file.") }
unless($data->{'info'}->{'sequence_file'}) { $logger->logdie("Sequence file definition not found in input file.") }

## fetch deflines
my $deflines = get_deflines($data->{'info'}->{'sequence_file'});

## This will hold all the alignments we've added to the document so far
my %alignments;

foreach my $qry_id ( keys %{$data->{'queries'}} ) {
    my ($model, $description, $score, $eval, $domain_cnt, $alignment_data);

    ## add the query sequence file to the doc
    my $seq = $doc->createAndAddSequence($qry_id, $qry_id, undef, $options{'query_mol_type'}, $options{'query_mol_class'});
    $seq->addBsmlLink('analysis', "\#$options{search_method}_analysis", 'input_of');
    $doc->createAndAddSeqDataImport($seq, 'fasta', $fasta_input, '', $qry_id) if($options{'fasta_input'});
    $doc->createAndAddBsmlAttribute($seq, 'defline', $deflines->{$qry_id}) if($deflines->{$qry_id});

    ## for each model matched, create a Seq-pair-alignment and record the overall score and
    ## overall E-value
    foreach my $hit_id (keys %{$data->{'queries'}->{$qry_id}->{'hits'}} ) {
	my $hit = $data->{'queries'}->{$qry_id}->{'hits'}->{$hit_id};
	next if (scalar keys %{$hit->{'domains'}} == 0);	#skip model hits that have no domain hits
	## add this model sequence if we haven't already
	unless( $doc->returnBsmlSequenceByIDR($hit_id) ) {
	    $doc->createAndAddSequence($hit_id, $hit->{'hit_description'}, undef, 
				       $options{'model_mol_type'}, $options{'model_mol_class'});
	}

	# Store all the hits as Seq-pair-alignments and all the domains as Seq-pair-runs
	if( exists( $hit->{'domains'} ) ) {	
	    my $aln_obj = $doc->createAndAddSequencePairAlignment(refseq => $qry_id, refstart => 0, 
								  compseq => $hit_id, class => 'match');
	    $aln_obj->addBsmlLink('analysis', "\#$options{search_method}_analysis", 'computed_by');
	    $doc->createAndAddBsmlAttribute($aln_obj, 'total_score', $hit->{'total_score'});
	    $doc->createAndAddBsmlAttribute($aln_obj, 'total_e_value',  $hit->{'total_evalue'});
	    

	    foreach my $domain ( sort { $a <=> $b } keys %{$hit->{'domains'}} ) {
		my $dh = $hit->{'domains'}->{$domain};
		my %options = ( 'alignment_pair' => $aln_obj,
				'runscore'       => $dh->{'domain_score'},
				'runlength'      => abs($dh->{'seq_t'} - $dh->{'seq_f'}) + 1,
				'comprunlength'  => abs($dh->{'hmm_t'} - $dh->{'hmm_f'}) + 1,
				'refpos'         => min($dh->{'seq_f'}, $dh->{'seq_t'}) - 1,
				'refcomplement'  => 0,
				'comppos'        => min($dh->{'hmm_f'}, $dh->{'hmm_t'}) - 1,
				'compcomplement' => 0,
				);

		my $run = $doc->createAndAddSequencePairRun( %options );
		$doc->createAndAddBsmlAttribute( $run, 'class', 'match_part');
		$doc->createAndAddBsmlAttributes($run, 
						 'e_value'    => $dh->{'domain_evalue'},
						 'domain_num' => $domain,
						 'domain_of'  => $hit->{'domain_count'}
						 );
	    } 
	}
    }		
}

## add the analysis element
$doc->createAndAddAnalysis('id'         => "$options{search_method}_analysis",
			   'sourcename' => $options{'output'},
			   'program'    => $data->{'info'}->{'program'},
			   'algorithm'  => $data->{'info'}->{'program'}
			   );
## now write the doc
$doc->write($options{'output'}, '', $options{gzip_output});

sub check_parameters {
## make sure input file exists
    if (! -e $options{'input'}) { $logger->logdie("input file $options{'input'} does not exist") }
## make user an output file was passed
    if (! $options{'output'}) { $logger->logdie("output option required!") }
## handle defaults
    $options{'search_method'} = 'hmmpfam3' unless ( $options{'search_method'} );
    if($options{'fasta_input'}) {
	$fasta_input = $options{'fasta_input'};
    }
    return 1;
}

sub min {
    my ($num1, $num2) = @_;
    if ($num1 < $num2) {
	return $num1;
    } else {
	return $num2;
    }
}

## retrieve deflines from a fasta file
sub get_deflines {
    my ($fasta_file) = @_;
    die("Pass in fasta_file") unless( defined( $fasta_file ) );

    my $deflines = {};
    my $ifh;
    if (! -e $fasta_file) {
	if (-e $fasta_file.".gz") {
	    $fasta_file .= ".gz";
	} elsif (-e $fasta_file.".gzip") {
	    $fasta_file .= ".gzip";
	}
    }
    if ($fasta_file =~ /\.(gz|gzip)$/) {
	open ($ifh, "<:gzip", $fasta_file)
	    || $logger->logdie("can't open input file '$fasta_file': $!");
    } else {
	open ($ifh, $fasta_file)
	    || $logger->logdie("Failed opening '$fasta_file' for reading: $!");
    }
    while (<$ifh>) {
	unless (/^>/) {
	    next;
	}
	chomp;
	if (/^>((\S+).*)$/) {
	    $deflines->{$2} = $1;
	}
    }
    close $ifh;
    if (scalar(keys(%{$deflines})) < 1) {
	$logger->warn("Defline lookup failed for '$fasta_file'");
    }
    return $deflines;
}
