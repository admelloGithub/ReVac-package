#!/usr/bin/perl

eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell

use lib (@INC,$ENV{"PERL_MOD_DIR"});
no lib "$ENV{PERL_MOD_DIR}/i686-linux";
no lib ".";


=head1 NAME

aragorn2bsml.pl - Creates a bsml document from aragorn raw
    output

=head1 SYNOPSIS

USAGE: aragorn2bsml.pl
            --input_file=/path/to/some/aragorn.raw
            --output=/path/to/aragorn.bsml
            --id_repository=/path/to/id_repository
            --fasta_input=/path/to/input.fsa
          [ --project=aa1
            --compress_output=1
            --log=/path/to/file.log
            --debug=4
            --help
          ]

=head1 OPTIONS

B<--input_file,-i>
    [REQUIRED] Raw output generated by aragorn using the -w option

B<--output,-o>
    [REQUIRED] The output bsml file.

B<--id_repository,-r>
    [REQUIRED] Id repository for use by Ergatis::IdGenerator.pm

B<--fasta_input,-a>
    [REQUIRED] The input file that was used as input for the glimmer3 run

B<--compress_output,-g>
    [OPTIONAL] The output file will be compressed for any non-zero value (gzip)

B<--project,-p>
    [OPTIONAL] Project name (used in id generation).  Can also use the token 'parse'.  
    aragorn2bsml.pl will then try to parse the project from the input file.  
    DEFAULT = 'parse'

B<--log,-l>
    Logfile.

B<--debug,-d>
    Larger number = more verbose.

B<--help,-h>
    Print this message

=head1  DESCRIPTION

This script is used to converts aragorns tab-delimited output into BSML.

=head1  INPUT

    Example Input format:

>mmycoides.assembly.1	31
T            c[98341,98417]	35	Cys(gca)
T          c[209233,209310]	35	Phe(gaa)
T          c[209317,209395]	36	Asp(gtc)
T          c[209397,209472]	34	Met(cat)
T          c[209494,209588]	38	Ser(tga)
T          c[209606,209684]	36	Met(cat)
T          c[209694,209772]	36	Met(cat)
T          c[209775,209852]	35	Ala(tgc)
MN	[889602,890012]	[87,173]	AEKNEENFEMPAFMINNASAGANYMFA**

=head1 OUTPUT

    Example Output Format


=head1  CONTACT

    Kevin Galens
    kgalens@tigr.org

=cut

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through);
use Pod::Usage;
use BSML::BsmlBuilder;
use Ergatis::IdGenerator;
use Ergatis::Logger;
use Data::Dumper;

####### GLOBALS AND CONSTANTS ###########
my $inputFile;                #Holds input files
my $project;                  #The project (ex aa1)
my $output;                   #Output file
my $idMaker;                  #The Ergatis::IdGenerator
my $bsml;                     #BSML::BsmlBuilder object object.
my $data;                     #Holds parsed aragorn information
my $inputFsa;                 #The fasta file input to aragorn
my $debug;                    #The debug variable
my $gzip;                     #If the output should be compressed
my $analysis_name = 'aragorn';#For the bsml links
########################################

my %options = ();
my $results = GetOptions (\%options, 
                          'input_file|i=s',
                          'output|o=s',
                          'project|p=s',
                          'id_repository|r=s',
                          'fasta_input|a=s',
                          'compress_output|g=s',
                          'log|l=s',
                          'debug=s',
                          'help|h') || &_pod;

#Setup the logger
my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename();
my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile,
				  'LOG_LEVEL'=>$options{'debug'});
$logger = $logger->get_logger();

# Check the options.
&check_parameters(\%options);

$data = &parseAragornData($inputFile);
print "Calling generate BSML\n";
$bsml = &generateBsml($data);

print "Writing to $output\n";
$bsml->write($output, '', $gzip);

######################## SUB ROUTINES #######################################
sub parseAragornData {
    my ($file) = @_;
    my $retval = {};
    my $seq = "";

    my $fh;
    open($fh, "< $file") or &_die("Could not open raw aragorn file ($file) for reading");

    while(<$fh>) {
        chomp;
        next if(/^\s+$/);

        #If we are on the header line
        if(/^>(\S+)/) {
            $seq = $1;
            next;
        #This means we found a tRNA
        } elsif( /^T/ ) {
            my ($comp, $start, $stop, $type, $antiCodon) = ($1, $2, $3, $4, $5) 
                if(/TI?\s+(c?)\[(\d+),(\d+)\]\s+\d+\s+(\w{3})\((\w{3})\)/);
            &_die("Couldn't parse tmRNA line $_") unless($start && $stop && $type && $antiCodon);
            
            $comp = 1 if($comp eq 'c');
            $comp = 0 if(!$comp || $comp != 1 );

            ($start, $stop) = ($start > $stop) ? ($stop, $start) : ($start, $stop);

            push(@{$retval->{$seq}->{'tRNA'}}, [$start, $stop, $comp, $type, $antiCodon]);
            

        #This means we found a tmRNA
        } elsif( /^M/ ) {
            
            my  ($comp, $start, $stop) = ($1, $2, $3) 
                if(/M[NP]\s+(c?)\[(\d+),(\d+)/);
            &_die("Couldn't parse tmRNA line $_") unless($start && $stop);

            $comp = 1 if($comp eq 'c');
            $comp = 0 if(!$comp || $comp != 1 );
            ($start, $stop) = ($start > $stop) ? ($stop, $start) : ($start, $stop);

            push(@{$retval->{$seq}->{'tmRNA'}}, [$start, $stop, $comp]);

        #This means we messed up
        } else {
            my $char = substr($_, 0, 1);
            &_die("The line did not start with a >, T, or M.  But it did start with a $char");
        }
        
        
    }

    return $retval;

}

sub generateBsml {
    my $data = shift;

    my $doc = new BSML::BsmlBuilder;

    open( IN, "< $inputFsa" ) or $logger->logdie("Unable to open $inputFsa");
    my $defline = <IN>;
    close( IN );
    my $inputId = $1 if( $defline =~ /^>(\S+)/ );

    $logger->logdie("Can't parse input id from $inputFsa") unless( $inputId );
    $inputId =~ s/\.$//;
    &createSequence( $doc, $inputId ) unless( scalar keys %$data );

    foreach my $seqId ( keys %$data ) {
        die("There is not sequence id ($seqId)") unless($seqId);
        my $seq = &createSequence( $doc, $seqId );

        while( my ($rnaType, $rnas) = each( %{$data->{$seqId}} ) ) {
            foreach my $rna ( @$rnas ) {
                &createRNAGene( $doc, $seq, $rna, $rnaType );
            }
        }
    }

    #Finish the document (add analysis)
    $doc->createAndAddAnalysis( id => "${analysis_name}_analysis", 
                                programversion => '1',
                                algorithm => 'aragorn',
                                name => 'aragorn' );

    return $doc;
    
}

sub createSequence {
    my ($bsml, $seqId) = @_;

    print "Called createSequnece on $seqId\n";

    #Find the entry in the fasta file
    my $fsa;
    open($fsa, "< $inputFsa") or die("Unable to open $inputFsa ($!)");

    my ($length, $defline);
    my $seq = "";
    my $found = 0;
    while(<$fsa>) {
        chomp;
        if(/^>($seqId.*)/) {
            $found = 1;
            $defline = $1;
        } elsif( /^>/ && $found ) {
            $length =  length($seq);
            $found = 0;
            last;
        } elsif( $found ) {
            $seq .= $_;
        }
    }

    my $class = $1 if($seqId =~ /[^\.]+\.(\w+)\./);
    die("Could not parse class from id ($seqId)") unless($class);

    my $seqObj = $bsml->createAndAddSequence( $seqId, '', $length, 'dna', $class);
    $seqObj->addBsmlLink( 'analysis', "#".$analysis_name."_analysis", "input_of" );
    $bsml->createAndAddBsmlAttribute( $seqObj, 'defline', $defline );
    $bsml->createAndAddSeqDataImport( $seqObj, 'fasta', $inputFsa, '', $seqId );
    return $seqObj;
    
}

sub createRNAGene {
    my ($doc, $seq, $rna, $rnaType) = @_;

    my $featTable = @{$seq->returnBsmlFeatureTableListR}[0];
    $featTable = $doc->createAndAddFeatureTable( $seq ) unless($featTable);
    die("Could not make feature table element") unless($featTable);
    

    my ($featId, $geneId);
    my %featG;
    foreach my $word ( (qw/ CDS gene exon /),$rnaType) {
        
        #Make the id
        $featId = $idMaker->next_id( 'type' => $word, 'project' => $project );
        
        #Create the feature
        my $feat = $doc->createAndAddFeature( $featTable, $featId, '', $word );
        die("Couldn't make feature object") unless($feat);

        #All features need the interval loc and  analysis link 
        $feat->addBsmlIntervalLoc( $rna->[0] -1, $rna->[1], $rna->[2] );
        $feat->addBsmlLink( 'analysis', "#".$analysis_name."_analysis", 'computed_by' );

        #If it's a tRNA feature, we should add some attributes to it
        #But only on the tRNA feature
        if( $word eq 'tRNA' ) {
            $doc->createAndAddBsmlAttribute( $feat, 'gene_product_name', "tRNA-".$rna->[3] );
            $doc->createAndAddBsmlAttribute( $feat, 'tRNA_anti-codon', uc($rna->[4]) );
        }

        #So we can add them all to feature groups
        $featG{$featId} = $word;

        #Save this for the group-set attr of the feature group element
        $geneId = $featId if( $word eq 'gene' );
        
    }

    #Create a feature group
    my $fg = $doc->createAndAddFeatureGroup( $seq, '', $geneId );
    foreach my $fId ( keys %featG ) {
        
        #Create a feature-group-member element for each of the feature types and add it to the feature group
        my $fgm = $doc->createAndAddFeatureGroupMember( $fg, $fId, $featG{$fId} );

    }

    
}

sub check_parameters {
    my $options = shift;

    my $error = "";

    &_pod if($options{'help'});

    if($options{'input_file'}) {
        $error .= "Option input_file ($options{'input_file'}) does not exist\n" 
            unless(-e $options{'input_file'});
        $inputFile = $options{'input_file'};
    } else {
        $error = "Option input_file is required\n";
    }

    unless($options{'output'}) {
        $error .= "Option output is required\n";
    } else {
        $output = $options{'output'};
    }

    unless($options{'id_repository'}) {
        $error .= "Option id_repository is required.  Please see Ergatis::IdGenerator ".
            "for details.\n";
    } else {
        $idMaker = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} );
        $idMaker->set_pool_size( 'tRNA' => 20 );
                                 
    }

    unless($options{'fasta_input'}) {
        $error .= "Option fasta_input is required\n";
    } else {
        $error .= "$options{'fasta_input'} (fasta_input) does not exist\n" 
            unless(-e $options{'fasta_input'});
        $inputFsa = $options{'fasta_input'};
    }

    
    unless($options{'project'}) {
        $project = &parseProjectName( $inputFsa ) if( $inputFsa );
    } else {
        $project = $options{'project'};
        $project = &parseProjectName( $inputFsa ) if($project eq 'parse' && $inputFsa);
    }

    unless($options{'compress_output'}) {
        $gzip = 0;
    } else {
        $gzip = 1;
    }
    
    if($options{'debug'}) {
        $debug = $options{'debug'};
    }
    
    unless($error eq "") {
        &_die($error);
    }
    
}


sub parseProjectName {
    my $input = shift;
    my $projectName;
    
    open(IN, "< $input" ) or $logger->logdie("Unable to open $input");
    my $defline = <IN>;
    close(IN);

    $projectName = $1 if( $defline =~ /^>([^\s\.]+)/ );
    $logger->logdie("Can't parse project name from $input") unless($projectName);

    return $projectName;
}

sub _pod {   
    pod2usage( {-exitval => 0, -verbose => 2, -output => \*STDERR} );
}

sub _die {
    my $msg = shift;
    $logger->logdie($msg);
}
