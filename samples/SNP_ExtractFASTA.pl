#!/usr/bin/perl

eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
BEGIN{foreach (@INC) {s/\/usr\/local\/packages/\/local\/platform/}};
use lib (@INC,$ENV{"PERL_MOD_DIR"});
no lib "$ENV{PERL_MOD_DIR}/i686-linux";
no lib ".";

use strict;
use warnings;

my $tilingsFile = $ARGV[0];
my $fastaFile = $ARGV[1];
my $outputPrefix = $ARGV[2];
my $database = $ARGV[3];
my %idLookup;

# open the tilings file generated by 'show-tiling' after nucmer analysis
open( TILINGS, $tilingsFile ) or die "Unable to open $tilingsFile\n";

# open the output multifasta file which will contain the assembly sequences in the tiling.

open( OUTFILE, ">$outputPrefix.tiled_asmbl.fasta" ) or die "Unable to open $outputPrefix.tiled_assemblies.fasta\n";

# skip the tilings header
<TILINGS>;

while( my $line = <TILINGS> )
{
    my @tile = split( "\t", $line );
    chomp( $tile[7] );

    # assembly identifier
    my $id = $tile[7];

    # orientation
    my $revCom = $tile[6];

    #pull the sequence data from input fasta
    my $seqDat = parse_multi_fasta( $fastaFile, $id );
   
    #perform a reverse complement operation if necessary.
    if( $revCom eq '-' )
    {
	$seqDat = reverse_complement( $seqDat );
	my $length = length($seqDat);
	$id .= "revcom:$length" ;
    }

    #Check for duplicates, output sequence data only once 

    if( !( $idLookup{$id} ) )
    {
	print OUTFILE ">$id\n";
	print OUTFILE "$seqDat\n";
    }

    $idLookup{$id} = 1;

    #Pull contig and coverage data if a database has been specified

    if( $database )
    {
	$id =~ s/revcom//;

	# This needs to be removed when we're in control of input data ie BSML -> Multifasta
	# fasta id should be an assembly id in the legacy TIGR database

	$id =~ s/ID//;

	system( "pull_contig -D $database -c $id -o /usr/local/scratch/chauser/anthrax/anthrax_contig.dir/$id" );
	system( "getCoverage --nogaps -t -o /usr/local/scratch/chauser/anthrax/anthrax_cov.dir/ /usr/local/scratch/chauser/anthrax/anthrax_contig.dir/$id" );
    }
}

close (OUTFILE);
close (TILINGS);

sub parse_multi_fasta {

  my $fasta_file = shift;
  my $specified_header = shift;
  
  open (IN, $fasta_file) or die "Unable to open $fasta_file due to $!";
  my $line = <IN>;
  my $seq_ref = [];
  while(defined($line)) {
    unless($line =~ /^>([^\s]+)/) {
      $line = <IN>;
    } else {
      my $header = $1;
      if($specified_header eq $header) {
	while(defined($line=<IN>) and $line !~ /^>/ ) {
	  next if($line =~/^\s+$/);                   #skip blank lines
	  chomp($line);
	  push(@$seq_ref, $line);
	}
	last;   #seq found, terminating fasta_file parasing
      } else { $line = <IN>; };  #wrong seq, keep looking
    }
    }
  close IN;
  
  my $final_seq = join("", @$seq_ref);
  
  return $final_seq; 
}

sub reverse_complement {

    my $seq = shift;

    $seq =~ s/\n//g;
    

    my $complementation = { 'A' => 'T',
                            'T' => 'A',
                            'C' => 'G',
                            'G' => 'C'
                          };

    my $rev_seq = reverse($seq);
    
    my $final_seq;
    foreach my $base (split("",$rev_seq)) {
        my $comple_base= $complementation->{$base};
        $comple_base = $base if(!$comple_base);
        $final_seq .= $comple_base;
    }

    return $final_seq;
}

