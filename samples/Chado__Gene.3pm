.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Chado::Gene 3"
.TH Chado::Gene 3 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
.Vb 1
\&  Gene.pm - Object representation of a gene
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Gene;
.PP
my \f(CW$gene\fR = new Gene('geneID');
.PP
#addWhatever(id, fmin, fmax, strand(0,1)), 
\&\f(CW$gene\fR\->addExon('exonID', 5, 100, 0);
\&\f(CW$gene\fR\->addPolypeptide('polypeptideID', 5, 100, 0);
\&\f(CW$gene\fR\->addTranscript('transcriptID', 5, 100, 0);
\&\f(CW$gene\fR\->addCDS('cdsID', 5, 100, 0);
\&\f(CW$gene\fR\->addFeature('startCodonID', 0, 3, 0);
.PP
#Create a group (each group represents an alternate form)
#(ie, alternative splicing).
\&\f(CW$filter\fR = { 'all' => 1 };
\&\f(CW$gene\fR\->createGroup('groupID', \f(CW$filter\fR); 
.SH "ADVANCED USAGE"
.IX Header "ADVANCED USAGE"
.Vb 3
\&    For adding features to groups, you can use a filter hash reference which
\&    allows the user to filter the types, id, or strand of features to include in
\&    a group.  The format would be as follows:
.Ve
.PP
.Vb 2
\&    $filter = { 'id' => 'exonID' };
\&    $filter = { 'type' => 'exon' };
.Ve
.PP
.Vb 2
\&    Or if you wanted all features in the gene to be added to a certain group
\&    you could use the all key with any non-zero value.
.Ve
.PP
.Vb 1
\&    $filter = { 'all' => 1 };
.Ve
.PP
.Vb 2
\&    When filtering on more than one parameter, the functionality defaults to
\&    include one of the listed parameters.  For example:
.Ve
.PP
.Vb 2
\&    $filter = { 'type' => 'exon',
\&                'strand' => 0 };
.Ve
.PP
.Vb 3
\&    Using this filter would include all exons and all features on the forward
\&    strand.  If instead you wanted only exons on the forward strand, use the 
\&    'and' key:
.Ve
.PP
.Vb 3
\&    $filter = { 'type' => 'exon',
\&                'strand' => 0,
\&                'and' => 1 };
.Ve
.PP
.Vb 3
\&    You can also filter on the start and stop coordinates.  To indicated greater than a plus
\&    should precede the number (be sure to put value in quotes to preserve the plus/minus sign).
\&    To indicate less than, you guessed it, a minus sign.  Example:
.Ve
.PP
.Vb 1
\&    $filter = { 'start' => "+6000" };
.Ve
.PP
.Vb 1
\&    Would include those features that had a start position of 6000 or higher.
.Ve
.PP
.Vb 2
\&    The filter can be used in the createGroup, addToGroup, or accessor (get) 
\&    subroutines.
.Ve
.PP
.Vb 4
\&    NOTE:
\&    Currently, there are no checks to ensure the inclusion of certain features
\&    within a gene.  For example, a gene doesn't have to have a CDS, polypeptide,
\&    or transcript feature to be a valid gene.
.Ve
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Kevin Galens
\&    kgalens@tigr.org
.Ve
.RE
.ie n .IP "$gene\->addCDS( $id\fR, \f(CW$fmin\fR, \f(CW$fmax\fR, \f(CW$strand );"
.el .IP "$gene\->addCDS( \f(CW$id\fR, \f(CW$fmin\fR, \f(CW$fmax\fR, \f(CW$strand\fR );"
.IX Item "$gene->addCDS( $id, $fmin, $fmax, $strand );"
\&\fBDescription:\fR Adds one \s-1CDS\s0 to the gene.
.PP
\&\fBParameters:\fR \f(CW$id\fR = unique id of the \s-1CDS\s0
               \f(CW$fmin\fR = start boundary of the \s-1CDS\s0
               \f(CW$fmax\fR = end boundary of the \s-1CDS\s0
               \f(CW$strand\fR = forward (0) or reverse (1)
.PP
\&\fBReturns:\fR The id of the \s-1CDS\s0 added.
.RE
.IP "$gene\->addMultiCDS($CDSs);"
.IX Item "$gene->addMultiCDS($CDSs);"
\&\fBDescription:\fR Sets all the CDSs of the gene.  Will remove all previously associated
    CDSs from the gene.
.PP
\&\fBParameters:\fR Array reference of Gene::Feature objects.
.PP
\&\fBReturns:\fR Number of CDSs added.
.RE
.IP "$gene\->getCDS([$filter]);"
.IX Item "$gene->getCDS([$filter]);"
\&\fBDescription:\fR Returns the CDSs related to the gene object based on
    the filter.
.PP
\&\fBParameters:\fR Optional filter parameter (see Gene.pm perldoc for 
                                          format of hash ref)
.PP
\&\fBReturns:\fR Reference to an array of cds.  Format:
    [$cds1, \f(CW$cds2\fR,...] 
.PP
.Vb 2
\&    where 
\&    $cds->{(id|start|stop|strand|type}} = value
.Ve
.RE
.ie n .IP "$gene\->addExon( $id\fR, \f(CW$fmin\fR, \f(CW$fmax\fR, \f(CW$strand );"
.el .IP "$gene\->addExon( \f(CW$id\fR, \f(CW$fmin\fR, \f(CW$fmax\fR, \f(CW$strand\fR );"
.IX Item "$gene->addExon( $id, $fmin, $fmax, $strand );"
\&\fBDescription:\fR Adds one exon to the gene.
.PP
\&\fBParameters:\fR \f(CW$id\fR = unique id of the exon
               \f(CW$fmin\fR = start boundary of the exon
               \f(CW$fmax\fR = end boundary of the exon
               \f(CW$strand\fR = forward (0) or reverse (1)
.PP
\&\fBReturns:\fR The id of the exon added.
.RE
.IP "$gene\->addMultiExons($exons);"
.IX Item "$gene->addMultiExons($exons);"
\&\fBDescription:\fR Sets all the exons of the gene.  Will remove all exons
    that were previously associated with gene.
.PP
\&\fBParameters:\fR Array Reference of Gene::Feature objects
.PP
\&\fBReturns:\fR Number of exons added.
.RE
.IP "$gene\->getExons([$filter]);"
.IX Item "$gene->getExons([$filter]);"
\&\fBDescription:\fR Returns the exons related to the gene object based on
    the filter.
.PP
\&\fBParameters:\fR Optional filter parameter (see Gene.pm perldoc for 
                                          format of hash ref)
.PP
\&\fBReturns:\fR Reference to an array of cds.  Format:
    [$cds1, \f(CW$cds2\fR,...] 
.PP
.Vb 2
\&    where 
\&    $cds->{(id|start|stop|strand|type}} = value
.Ve
.RE
.ie n .IP "$gene\->addFeature( $id\fR, \f(CW$fmin\fR, \f(CW$fmax\fR, \f(CW$strand\fR, \f(CW$type );"
.el .IP "$gene\->addFeature( \f(CW$id\fR, \f(CW$fmin\fR, \f(CW$fmax\fR, \f(CW$strand\fR, \f(CW$type\fR );"
.IX Item "$gene->addFeature( $id, $fmin, $fmax, $strand, $type );"
\&\fBDescription:\fR Adds one feature to the gene.
.PP
\&\fBParameters:\fR \f(CW$id\fR = unique id of the exon
               \f(CW$fmin\fR = start boundary of the exon
               \f(CW$fmax\fR = end boundary of the exon
               \f(CW$strand\fR = forward (0) or reverse (1)
               \f(CW$type\fR = the type of feature added (should be a \s-1SO\s0 term).
.PP
\&\fBReturns:\fR The id of the feature added.
.RE
.IP "$gene\->addMultiFeatures($features);"
.IX Item "$gene->addMultiFeatures($features);"
\&\fBDescription:\fR Sets multiple features of the gene.  
.PP
\&\fBParameters:\fR Array reference of features
.PP
\&\fBReturns:\fR Number of features added.
.RE
.IP "$gene\->getFeatures([$filter]);"
.IX Item "$gene->getFeatures([$filter]);"
\&\fBDescription:\fR Returns the features related to the gene object based on
    the filter.
.PP
\&\fBParameters:\fR Optional filter parameter (see Gene.pm perldoc for 
                                          format of hash ref)
.PP
\&\fBReturns:\fR Returns an array reference of features.
    \f(CW$feature\fR\->{(id|start|stop|strand|type)}
.RE
.IP "$gene\->getFeature($id);"
.IX Item "$gene->getFeature($id);"
\&\fBDescription:\fR Returns a single feature reference for the feature with specified id.
.PP
\&\fBParameters:\fR feature id
.PP
\&\fBReturns:\fR Returns a feature reference    
.RE
.ie n .IP "$gene\->addFeatureScore($featId, $scoreType\fR, \f(CW$value);"
.el .IP "$gene\->addFeatureScore($featId, \f(CW$scoreType\fR, \f(CW$value\fR);"
.IX Item "$gene->addFeatureScore($featId, $scoreType, $value);"
\&\fBDescription:\fR Sets the score type for a feature
.PP
\&\fBParameters:\fR \f(CW$featId\fR \- The id of the feature to associate the score with
               \f(CW$scoreType\fR \- The type of score (ex. p\-value, bit_score, etc.)
                            Should be found in an ontology
               \f(CW$value\fR \- The actual score.
.PP
\&\fBReturns:\fR Returns the id of the feature to which the score was added.
.RE
.ie n .IP "$gene\->addFeatureAttribute($featId, $name\fR, \f(CW$content);"
.el .IP "$gene\->addFeatureAttribute($featId, \f(CW$name\fR, \f(CW$content\fR);"
.IX Item "$gene->addFeatureAttribute($featId, $name, $content);"
\&\fBDescription:\fR Adds an attribute under a feature.
.PP
\&\fBParameters:\fR \f(CW$featId\fR \- The id of the feature to add an attribute to
               \f(CW$name\fR \- Attribute name
               \f(CW$content\fR \- Attribute content
.PP
\&\fBReturns:\fR Returns feature reference for the modified feature or undef if id was not found
.RE
.ie n .IP "$gene\->setId( $newID );"
.el .IP "$gene\->setId( \f(CW$newID\fR );"
.IX Item "$gene->setId( $newID );"
\&\fBDescription:\fR Set the id of the gene object
.PP
\&\fBParameters:\fR Scalar id of the gene object.
.PP
\&\fBReturns:\fR The new \s-1ID\s0 of the gene.
.RE
.IP "$gene\->addMulitPolypeptide($polypeptides);"
.IX Item "$gene->addMulitPolypeptide($polypeptides);"
\&\fBDescription:\fR Sets all the polypeptides of the gene.  Will remove all polypeptides
    that were previously associated with gene.
.PP
\&\fBParameters:\fR Array Reference of Gene::Feature objects
.PP
\&\fBReturns:\fR Number of polypeptides added.
.RE
.IP "$gene\->getPolypeptide([$filter]);"
.IX Item "$gene->getPolypeptide([$filter]);"
\&\fBDescription:\fR Returns the polypeptides related to the gene object based on
    the filter.
.PP
\&\fBParameters:\fR Optional filter parameter (see Gene.pm perldoc for 
                                          format of hash ref)
.PP
\&\fBReturns:\fR Hash Reference.  Format:
    \f(CW$hashRef\fR\->{polypeptideID}\->{(start|stop|strand|type)} = value
.RE
.ie n .IP "$gene\->addTranscript( $id\fR, \f(CW$fmin\fR, \f(CW$fmax\fR, \f(CW$strand );"
.el .IP "$gene\->addTranscript( \f(CW$id\fR, \f(CW$fmin\fR, \f(CW$fmax\fR, \f(CW$strand\fR );"
.IX Item "$gene->addTranscript( $id, $fmin, $fmax, $strand );"
\&\fBDescription:\fR Adds one transcript to the gene.
.PP
\&\fBParameters:\fR \f(CW$id\fR = unique id of the transcript
               \f(CW$fmin\fR = start boundary of the transcript
               \f(CW$fmax\fR = end boundary of the transcript
               \f(CW$strand\fR = forward (0) or reverse (1)
.PP
\&\fBReturns:\fR The id of the transcript added.
.RE
.IP "$gene\->addMultiTranscript($transcripts);"
.IX Item "$gene->addMultiTranscript($transcripts);"
\&\fBDescription:\fR Sets all the transcripts of the gene.  Will remove all transcripts
    that were previously associated with gene.
.PP
\&\fBParameters:\fR Reference to an array of Gene::Feature objects
.PP
\&\fBReturns:\fR Number of transcripts added.
.RE
.IP "$gene\->getTranscript([$filter]);"
.IX Item "$gene->getTranscript([$filter]);"
\&\fBDescription:\fR Returns the transcripts related to the gene object based on
    the filter.
.PP
\&\fBParameters:\fR Optional filter parameter (see Gene.pm perldoc for 
                                          format of hash ref)
.PP
\&\fBReturns:\fR Hash Reference.  Format:
    \f(CW$hashRef\fR\->{transcriptID}\->{(start|stop|strand|type)} = value
.RE
.IP "$gene\->setSeqId($seqId);"
.IX Item "$gene->setSeqId($seqId);"
\&\fBDescription:\fR Sets sequence upon which the gene is located.
.PP
\&\fBParameters:\fR The new sequence id
.PP
\&\fBReturns:\fR The new sequence id
.RE
.ie n .IP "$gene\->createGroup($groupID[, $filter]);"
.el .IP "$gene\->createGroup($groupID[, \f(CW$filter\fR]);"
.IX Item "$gene->createGroup($groupID[, $filter]);"
\&\fBDescription:\fR Add a pre-existing feature to specified group identified by 
    group id.  If the group exists, the feature(s) will be added to it.
.PP
\&\fBParameters:\fR \f(CW$groupID\fR \- Identifier of the group
               \f(CW$filter\fR \- see format in Gene.pm perldoc (hash ref)
.PP
\&\fBReturns:\fR The number of features added to the specified group.
.RE
.ie n .IP "$gene\->removeFromGroup($groupID[, $filter]);"
.el .IP "$gene\->removeFromGroup($groupID[, \f(CW$filter\fR]);"
.IX Item "$gene->removeFromGroup($groupID[, $filter]);"
\&\fBDescription:\fR Removes features from specified group based on the filter.
    If no filter is provided, the group is removed.
.PP
\&\fBParameters:\fR \f(CW$groupID\fR \- Identifier of the group
               \f(CW$filter\fR \- see Gene.pm perldoc for format
.PP
\&\fBReturns:\fR The number of features deleted.
.RE
.IP "$gene\->getGroup($groupId);"
.IX Item "$gene->getGroup($groupId);"
\&\fBDescription:\fR To retrieve all the features in the group.
.PP
\&\fBParameters:\fR \f(CW$groupId\fR \- Unique identifier of a group
.PP
\&\fBReturns:\fR Nothing if group does not exist, a hash ref containing all
    the features if it does
.RE
.IP "$gene\->printGroup($groupID);"
.IX Item "$gene->printGroup($groupID);"
\&\fBDescription:\fR Prints all members of a specified group
.PP
\&\fBParameters:\fR \f(CW$groupID\fR \- Identifier for the group to be printed.
.PP
\&\fBReturns:\fR The number of features printed
.RE
.IP "printFeatures($feats);"
.IX Item "printFeatures($feats);"
\&\fBDescription:\fR Class subroutine that will print a set of features
.PP
\&\fBParameters:\fR \f(CW$feats\fR \- hashRef (for format see the return value of an accessor 
                                 subroutine (getWhatever)).
.PP
\&\fBReturns:\fR The number of features printed.
.RE
.IP "$gene\->filterFunction($filter);"
.IX Item "$gene->filterFunction($filter);"
\&\fBDescription:\fR Will filter a genes features based on the filter hash reference.
   For a description of the format of this filter please see the documentation of
   this module.
.PP
\&\fBParameters:\fR \f(CW$filter\fR \- hashreference
.PP
\&\fBReturns:\fR A hash of features based on the filter
