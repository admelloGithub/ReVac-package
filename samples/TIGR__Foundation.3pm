.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TIGR::Foundation 3"
.TH TIGR::Foundation 3 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
TIGR::Foundation \- TIGR Foundation object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TIGR::Foundation;
\&  my $obj_instance = new TIGR::Foundation;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module defines a structure for Perl programs to utilize
logging, version reporting, and dependency checking in a simple way.
.IP "$obj_instance = new TIGR::Foundation;" 4
.IX Item "$obj_instance = new TIGR::Foundation;"
This function creates a new instance of the TIGR::Foundation
object.  A reference pointing to the object is returned on success.  Otherwise,
this method returns undefined.
.ie n .IP "$value = $obj_instance\->getProgramInfo($field_type);" 4
.el .IP "$value = \f(CW$obj_instance\fR\->getProgramInfo($field_type);" 4
.IX Item "$value = $obj_instance->getProgramInfo($field_type);"
This function returns field values for specified field types describing
attributes of the program.  The \f(CW$field_type\fR parameter must be a listed
attribute: \f(CW\*(C`name\*(C'\fR, \f(CW\*(C`invocation\*(C'\fR, \f(CW\*(C`env_path\*(C'\fR, \f(CW\*(C`abs_path\*(C'\fR.
The \f(CW\*(C`name\*(C'\fR field specifies the bare name of the executable.  The
\&\f(CW\*(C`invocation\*(C'\fR field specifies the command line arguments passed to the
executable.   The \f(CW\*(C`env_path\*(C'\fR value returns the environment path to the
working directory.  The \f(CW\*(C`abs_path\*(C'\fR value specifies the absolute path to the
working directory.  If \f(CW\*(C`env_path\*(C'\fR is found to be inconsistent, then that
value will return the \f(CW\*(C`abs_path\*(C'\fR value.  If an invalid \f(CW$field_type\fR is 
passed, the function returns undefined.  
.ie n .IP "$exit_code = $obj_instance\->runCommand($command_str);" 4
.el .IP "$exit_code = \f(CW$obj_instance\fR\->runCommand($command_str);" 4
.IX Item "$exit_code = $obj_instance->runCommand($command_str);"
This function passes the argument \f(CW$command_str\fR to /bin/sh
for processing.  The return value is the exit code of the 
\&\f(CW$command_str\fR.  If the exit code is not defined, then either the signal or
core dump value of the execution is returned, whichever is applicable.  Perl
variables \f(CW$?\fR and \f(CW$!\fR are set accordingly.  If \f(CW$command_str\fR is not 
defined, this function returns undefined.  Log messages are recorded at log
level 4 to indicate the type of exit status and the corresponding code.
A failure to start the program (invalid program) results in return code \-1.
.IP "$obj_instance\->\fIprintDependInfo()\fR;" 4
.IX Item "$obj_instance->printDependInfo();"
The \f(CW\*(C`printDependInfo()\*(C'\fR function prints the dependency list created by
\&\f(CW\*(C`addDependInfo()\*(C'\fR.  One item is printed per line.
.IP "$obj_instance\->\fIprintDependInfoAndExit()\fR;" 4
.IX Item "$obj_instance->printDependInfoAndExit();"
The \f(CW\*(C`printDependInfoAndExit()\*(C'\fR function prints the dependency list created by
\&\f(CW\*(C`addDependInfo()\*(C'\fR.  One item is printed per line.  The function exits with
exit code 0. 
.IP "$obj_instance\->addDependInfo(@depend_list);" 4
.IX Item "$obj_instance->addDependInfo(@depend_list);"
The \f(CW\*(C`addDependInfo()\*(C'\fR function adds \f(CW@depend_list\fR information
to the dependency list.  If \f(CW@depend_list\fR is empty, the internal
dependency list is emptied.  Contents of \f(CW@depend_list\fR are not checked
for validity (eg. they can be composed entirely of white space or
multiple files per record).  The first undefined record in \f(CW@depend_list\fR
halts reading in of dependency information.
.ie n .IP "$version_string = $obj_instance\fR\->\fIgetVersionInfo();" 4
.el .IP "$version_string = \f(CW$obj_instance\fR\->\fIgetVersionInfo()\fR;" 4
.IX Item "$version_string = $obj_instance->getVersionInfo();"
The \f(CW\*(C`getVersionInfo()\*(C'\fR function returns the version information set by the
\&\f(CW\*(C`setVersionInfo()\*(C'\fR function.
.IP "$obj_instance\->\fIprintVersionInfo()\fR;" 4
.IX Item "$obj_instance->printVersionInfo();"
The \f(CW\*(C`printVersionInfo()\*(C'\fR function calls the version handler, if set.  If not,
it prints the version information set by the \f(CW\*(C`setVersionInfo()\*(C'\fR function. 
If there is no defined version information, a message is returned notifying 
the user.
.IP "$obj_instance\->\fIprintVersionInfoAndExit()\fR;" 4
.IX Item "$obj_instance->printVersionInfoAndExit();"
The \f(CW\*(C`printVersionInfoAndExit()\*(C'\fR function calls the version handler, if set.
Otherwise, it prints prints version info set by the \f(CW\*(C`setVersionInfo()\*(C'\fR 
function.  If there is no defined version information, a message is printed
notifying the user.  This function calls exit with exit code 0. 
.IP "$obj_instance\->setVersionInfo($version_string);" 4
.IX Item "$obj_instance->setVersionInfo($version_string);"
The \f(CW\*(C`setVersionInfo()\*(C'\fR function sets the version information to be reported
by \f(CW\*(C`getVersionInfo()\*(C'\fR.  If \f(CW$version_string\fR is empty, invalid, or
undefined, the stored version information will be undefined.
.IP "$obj_instance\->setVersionHandler($function_ref);" 4
.IX Item "$obj_instance->setVersionHandler($function_ref);"
The \f(CW\*(C`setVersionHandler()\*(C'\fR method establishes a callback function for handling
the reporting of version information to the user.  If a handler is set, then
any information passed in via \f(CW\*(C`setVersionInfo()\*(C'\fR is not reported.  To
remove the handler, call this method without any arguments.  If a handler is
not a proper code reference, this method returns undefined and does not set
a handler.  This method returns 1 on success.
.IP "$obj_instance\->\fIprintHelpInfo()\fR;" 4
.IX Item "$obj_instance->printHelpInfo();"
The \f(CW\*(C`printHelpInfo()\*(C'\fR function prints the help information passed by the
\&\f(CW\*(C`setHelpInfo()\*(C'\fR function.
.IP "$obj_instance\->\fIprintHelpInfoAndExit()\fR;" 4
.IX Item "$obj_instance->printHelpInfoAndExit();"
The \f(CW\*(C`printHelpInfoAndExit()\*(C'\fR function prints the help info passed by the
\&\f(CW\*(C`setHelpInfo()\*(C'\fR function.  This function exits with exit code 0.
.IP "$obj_instance\->setHelpInfo($help_string);" 4
.IX Item "$obj_instance->setHelpInfo($help_string);"
The \f(CW\*(C`setHelpInfo()\*(C'\fR function sets the help information via \f(CW$help_string\fR.
If \f(CW$help_string\fR is undefined, invalid, or empty, the help information 
is undefined.
.IP "$obj_instance\->\fIprintUsageInfo()\fR;" 4
.IX Item "$obj_instance->printUsageInfo();"
The \f(CW\*(C`printUsageInfo()\*(C'\fR function prints the usage information reported by the
\&\f(CW\*(C`setUsageInfo()\*(C'\fR function.  If no usage information is defined, but help
information is defined, help information will be printed.
.IP "$obj_instance\->\fIprintUsageInfoAndExit()\fR;" 4
.IX Item "$obj_instance->printUsageInfoAndExit();"
The \f(CW\*(C`printUsageInfoAndExit()\*(C'\fR function prints the usage information the
reported by the \f(CW\*(C`setUsageInfo()\*(C'\fR function and exits with status 1.
.IP "$obj_instance\->setUsageInfo($usage_string);" 4
.IX Item "$obj_instance->setUsageInfo($usage_string);"
The \f(CW\*(C`setUsageInfo()\*(C'\fR function sets the usage information via \f(CW$usage_string\fR.
If \f(CW$usage_string\fR is undefined, invalid, or empty, the usage information 
is undefined.
.IP "$valid = isReadableFile($file_name);" 4
.IX Item "$valid = isReadableFile($file_name);"
This function accepts a single scalar parameter containing a file name.
If the file corresponding to the file name is a readable plain file or symbolic
link, this function returns 1.  Otherwise, the function returns 0.  If the file
name passed is undefined, this function returns 0 as well.
.IP "$valid = isExecutableFile($file_name);" 4
.IX Item "$valid = isExecutableFile($file_name);"
This function accepts a single scalar parameter containing a file name.
If the file corresponding to the file name is an executable plain file
or symbolic link, this function returns 1.  Otherwise, the function returns 0.
If the file name passed is undefined, this function returns 0 as well.
.IP "$valid = isWritableFile($file_name);" 4
.IX Item "$valid = isWritableFile($file_name);"
This function accepts a single scalar parameter containing a file name.
If the file corresponding to the file name is a writable plain file
or symbolic link, this function returns 1.  Otherwise, the function returns 0.
If the file name passed is undefined, this function returns 0 as well.
.IP "$valid = isCreatableFile($file_name);" 4
.IX Item "$valid = isCreatableFile($file_name);"
This function accepts a single scalar parameter containing a file name.  If
the file corresponding to the file name is creatable this function returns 1.
The function checks if the location of the file is writable by the effective
user id (\s-1EUID\s0).  If the file location does not exist or the location is not
writable, the function returns 0.  If the file name passed is undefined,
this function returns 0 as well.  Note that files with suffix \fI/\fR are not
supported under \s-1UNIX\s0 platforms, and will return 0.
.IP "$valid = isReadableDir($directory_name);" 4
.IX Item "$valid = isReadableDir($directory_name);"
This function accepts a single scalar parameter containing a directory name.
If the name corresponding to the directory is a readable, searchable directory 
entry, this function returns 1.  Otherwise, the function returns 0.  If the
name passed is undefined, this function returns 0 as well.
.IP "$valid = isWritableDir($directory_name);" 4
.IX Item "$valid = isWritableDir($directory_name);"
This function accepts a single scalar parameter containing a directory name.
If the name corresponding to the directory is a writable, searchable directory 
entry, this function returns 1.  Otherwise, the function returns 0.  If the
name passed is undefined, this function returns 0 as well.
.IP "$valid = isCreatableDir($directory_name);" 4
.IX Item "$valid = isCreatableDir($directory_name);"
This function accepts a single scalar parameter containing a directory name.  
If the name corresponding to the directory is creatable this function returns 
1. The function checks if the immediate parent of the directory is writable by
the effective user id (\s-1EUID\s0).  If the parent directory does not exist or the 
tree is not writable, the function returns 0.  If the directory name passed is
undefined, this function returns 0 as well.
.IP "$valid = isCreatablePath($path_name);" 4
.IX Item "$valid = isCreatablePath($path_name);"
This function accepts a single scalar parameter containing a path name.  If
the \f(CW$path_name\fR is creatable this function returns 1. The function checks 
if the directory hierarchy of the path is creatable or writable by the
effective user id (\s-1EUID\s0).  This function calls itself recursively until
an existing directory node is found.  If that node is writable, ie. the path
can be created in it, then this function returns 1.  Otherwise, the function
returns 0.  This function also returns zero if the \f(CW$path_name\fR supplied
is disconnected from a reachable directory tree on the file system.
If the path already exists, this function returns 0.  The \f(CW$path_name\fR may
imply either a path to a file or a directory.  Path names may be relative or
absolute paths.  Any unresolvable relative paths will return 0 as well.  This
includes paths with \fI..\fR back references to nonexistent directories.
This function is recursive whereas \f(CW\*(C`isCreatableFile()\*(C'\fR and 
\&\f(CW\*(C`isCreatableDir()\*(C'\fR are not.
.IP "$date_string = getISODate($tm);" 4
.IX Item "$date_string = getISODate($tm);"
This function returns the \s-1ISO\s0 8601 datetime as a string given a time
structure as returned by the \f(CW\*(C`time\*(C'\fR function.  If no arguments
are supplied, this function returns the current time.  If incorrect
arguments are supplied, this function returns undefined.
.IP "$date_string = getSybaseDate(@tm);" 4
.IX Item "$date_string = getSybaseDate(@tm);"
This function returns a Sybase formatted datetime as a string given a time
structure as returned by the \f(CW\*(C`time\*(C'\fR function.  If no arguments
are supplied, this function returns the current time.  If incorrect
arguments are supplied, this function returns undefined.  The date string
returned is quoted according to Sybase requirements.
.IP "$date_string = getMySQLDate(@tm);" 4
.IX Item "$date_string = getMySQLDate(@tm);"
This function returns a MySQL formatted datetime as a string given a time
structure as returned by the \f(CW\*(C`time\*(C'\fR function.  If no arguments
are supplied, this function returns the current time.  If incorrect
arguments are supplied, this function returns undefined.  The datetime string
returned is prequoted according to MySQL requirements.
.IP "$date_string = getFilelabelDate(@tm);" 4
.IX Item "$date_string = getFilelabelDate(@tm);"
This function returns the date (not time) as a compressed string
suitable for use as part of a file name.  The format is \s-1YYMMDD\s0.
The optional parameter should be a time structure as returned by 
the \f(CW\*(C`time\*(C'\fR function.  If no arguments are supplied, the current time
is used.  If incorrect arguments are supplied, this function returns
undefined.
.ie n .IP "$date_string = $obj_instance\->getLogfileDate(@tm);" 4
.el .IP "$date_string = \f(CW$obj_instance\fR\->getLogfileDate(@tm);" 4
.IX Item "$date_string = $obj_instance->getLogfileDate(@tm);"
This function returns the datetime as a formatted string
suitable for use as a log entry header.  The optional parameter
should be a time structure as returned by the \f(CW\*(C`time\*(C'\fR function.
If no arguments are supplied, this function uses the current time.
If incorrect arguments are supplied, this function sets the date/time fields
of the log entry string to \f(CW\*(C` INVALID|XXXXXX|\*(C'\fR.
.IP "$obj_instance\->setDebugLevel($new_level);" 4
.IX Item "$obj_instance->setDebugLevel($new_level);"
This function sets the level of debug reporting according to \f(CW$new_level\fR.
If \f(CW$new_level\fR is less than 0, all debug reporting is turned off and 
\&\f(CW\*(C`getDebugLevel()\*(C'\fR will report undefined.  If \f(CW$new_level\fR is not specified,
the debug level is set to 0.  For compatibility, this function will also accept
the debug level as the second parameter.  In such cases, the first parameter
is checked only if the second parameter is invalid.  By default, the debug
level is undefined.
.ie n .IP "$level = $obj_instance\fR\->\fIgetDebugLevel();" 4
.el .IP "$level = \f(CW$obj_instance\fR\->\fIgetDebugLevel()\fR;" 4
.IX Item "$level = $obj_instance->getDebugLevel();"
This function returns the current debug level.  If the debug level has
not been set, this method returns <undef>.
.IP "$obj_instance\->setLogFile($log_file);" 4
.IX Item "$obj_instance->setLogFile($log_file);"
This function sets the log file name for use by the \f(CW\*(C`logLocal()\*(C'\fR function.
\&\fBThe programmer should call this function before invoking \f(CB\*(C`setDebugLevel()\*(C'\fB\fR
if the default log file is not to be used.  The new log file name is the
only parameter.  Future calls to \f(CW\*(C`logLocal()\*(C'\fR or \f(CW\*(C`bail()\*(C'\fR log to \f(CW$log_file\fR 
if it is successfully opened.  If the new log file is not successfully opened, 
the function will try to open the default log file, \fIprogram_name.log\fR.
If that file cannot be opened, \fI/tmp/program_name.$process_id.log\fR will
be used.  If no parameter is passed, this method does nothing.   For
compatibility, this method accepts the second parameter as the log file.  The
first parameter is ignored in such cases.  \fB\s-1NOTE:\s0\fR log files (including the
defailt log file) with relative paths will track with program execution
whenever a change of directory is made.
.ie n .IP "$log_file_name = $obj_instance\fR\->\fIgetLogFile();" 4
.el .IP "$log_file_name = \f(CW$obj_instance\fR\->\fIgetLogFile()\fR;" 4
.IX Item "$log_file_name = $obj_instance->getLogFile();"
This function returns the name of the log file to be used for printing
log messages.  We return undefined if there are no more log files to bind.
.ie n .IP "$error_file_name = $obj_instance\fR\->\fIgetErrorFile();" 4
.el .IP "$error_file_name = \f(CW$obj_instance\fR\->\fIgetErrorFile()\fR;" 4
.IX Item "$error_file_name = $obj_instance->getErrorFile();"
This function returns the name of the error file to be used for printing
error messages.  The error file is derived from the log file; a \fI.log\fR
extension is replaced by a \fI.error\fR extension.  If there is no \fI.log\fR
extension, then \fI.error\fR is appended to the log file name.  We return
undefined if there are no more log files to bind.
.IP "$obj_instance\->logAppend($log_append_flag);" 4
.IX Item "$obj_instance->logAppend($log_append_flag);"
Passing \f(CW0\fR signals truncation of log files while \f(CW1\fR signals appending.
By default, log files are truncated at the start of program execution or
logging.  Error files are controlled by this method as well.  Any truncation
occurs before the next write.  For compatibility, this method accepts and
prefers a second parameter argument for the log-append flag.
.ie n .IP "$obj_instance\->logLocal($log_message, $log_level);" 4
.el .IP "$obj_instance\->logLocal($log_message, \f(CW$log_level\fR);" 4
.IX Item "$obj_instance->logLocal($log_message, $log_level);"
The \f(CW\*(C`logLocal()\*(C'\fR function takes two arguments.  The \f(CW$log_message\fR
argument specifies the message to be written to the log file.  The
\&\f(CW$log_level\fR argument specifies the level at which \f(CW$log_message\fR is printed.
The active level of logging is set via the \f(CW\*(C`setDebugLevel()\*(C'\fR function.
Only messages at \f(CW$log_level\fR less than or equal to the active debug
level are logged.  The default debug level is undefined (no logging).  Note, a
trailing new line, if it exists, is stripped from the log message.
.IP "$obj_instance\->logError($log_message,$flag);" 4
.IX Item "$obj_instance->logError($log_message,$flag);"
The \f(CW\*(C`logError()\*(C'\fR function takes two arguments, the second one being optional. 
The \f(CW$log_message\fR argument specifies the message to be written to the error 
file. If the \f(CW$flag\fR argument is defined and is non\-zero, the \f(CW$log_message\fR
is also written to \s-1STDERR\s0. The \f(CW$log_message\fR is also passed to \f(CW\*(C`logLocal\*(C'\fR.
A message passed via \fIlogError()\fR will always get logged to the log file 
regardles of the debug level.  Note, a trailing new line, if it exists, is 
stripped from the log message.
.IP "$obj_instance\->bail($log_message);" 4
.IX Item "$obj_instance->bail($log_message);"
The \f(CW\*(C`bail()\*(C'\fR function takes a single required argument.  The \f(CW$log_message\fR
argument specifies the message to be passed to \f(CW\*(C`logLocal()\*(C'\fR and written
to standard error.  All messages passed to \f(CW\*(C`bail()\*(C'\fR are written to the 
log and error files.  The \f(CW\*(C`bail()\*(C'\fR function calls \f(CWexit(1)\fR to terminate the
program.  Optionally, a second positive integer argument can be passed as the
exit code to use. Trailing new lines are stripped from the log message. 
.ie n .IP "$getopts_error_code = $obj_instance\->TIGR_GetOptions(@getopts_arguments);" 4
.el .IP "$getopts_error_code = \f(CW$obj_instance\fR\->TIGR_GetOptions(@getopts_arguments);" 4
.IX Item "$getopts_error_code = $obj_instance->TIGR_GetOptions(@getopts_arguments);"
This function extends \f(CW\*(C`Getopt::Long::GetOptions()\*(C'\fR.  It may be used
as \f(CW\*(C`GetOptions()\*(C'\fR is used.  \s-1TIGR\s0 standard options are handled automatically.
Using this method promotes proper module behavior. 
.Sp
The following options are defined by this function:
.RS 4
.IP "\-appendlog <flag>" 4
.IX Item "-appendlog <flag>"
Passing '1' to this argument turns on log file appending.  Log files are
truncated by default.
.IP "\-debug <level>" 4
.IX Item "-debug <level>"
Set debugging to <level>.
.IP "\-logfile <file>" 4
.IX Item "-logfile <file>"
Set the \s-1TIGR\s0 Foundation log file to <file>.  \s-1NOTE\s0!!!  Log files specified
with relative paths will \*(L"track\*(R" the program as directories change!!!
.IP "\-version, \-V" 4
.IX Item "-version, -V"
Print version information and exit.
.IP "\-help, \-h" 4
.IX Item "-help, -h"
Print help information and exit.
.IP "\-depend" 4
.IX Item "-depend"
Print dependency information and exit.
.RE
.RS 4
.Sp
\&\fBThe options defined by \f(CB\*(C`TIGR_GetOptions()\*(C'\fB cannot be overridden or recorded\fR.
\&\f(CW\*(C`GetOptions()\*(C'\fR default variables, ie. those of the form \f(CW\*(C`$opt_\f(CIoptionname\f(CW\*(C'\fR,
are not supported.  This function will return 1 on success.  This method does
not throw an exception on failure to parse command line parameters \- this is
unlike Getopt::Long.
.RE
.SH "USAGE"
.IX Header "USAGE"
To use this module, load the \f(CW\*(C`TIGR::Foundation\*(C'\fR package
via the \f(CW\*(C`use\*(C'\fR function.  Then, create a new instance of the
object via the \f(CW\*(C`new()\*(C'\fR method, as shown below.  If applicable,
\&\f(CW\*(C`START\*(C'\fR and \f(CW\*(C`FINISH\*(C'\fR log messages are printed when the object
is created and destroyed, respectively.  It is advisable to 
keep the instance of the object in scope for the whole program
to achieve maximum functionality.
.PP
An example script using this module follows:
.PP
.Vb 2
\&   use strict;
\&   use TIGR::Foundation;
.Ve
.PP
.Vb 1
\&   my $tfobject = new TIGR::Foundation;
.Ve
.PP
.Vb 4
\&   MAIN: 
\&   {
\&      # The following dependencies are not used in
\&      # this script, but are provided as an example.
.Ve
.PP
.Vb 1
\&      my @DEPEND = ("/usr/bin/tee", "/sbin/stty");
.Ve
.PP
.Vb 3
\&      # The user defined $VERSION variable is usable by Perl.
\&      # The auto defined $REVISION variable stores the RCS/CVS revision
\&      # The user defined $VERSION_STRING reports both.
.Ve
.PP
.Vb 3
\&      my $VERSION = '1.0';
\&      my $REVISION = (qw$Revision: 1.1 $)[-1];
\&      my $VERSION_STRING = "$VERSION (Build $REVISION)";
.Ve
.PP
.Vb 1
\&      my $HELP_INFO = "This is my help\en";
.Ve
.PP
.Vb 2
\&      # All of the necessary information must be passed
\&      # to the foundation object instance, as below.
.Ve
.PP
.Vb 3
\&      $tfobject->addDependInfo(@DEPEND);
\&      $tfobject->setVersionInfo($VERSION_STRING);
\&      $tfobject->setHelpInfo($HELP_INFO);
.Ve
.PP
.Vb 2
\&      my $input_file;
\&      my $output_file;
.Ve
.PP
.Vb 2
\&      $tfobject->TIGR_GetOptions("input=s" => \e$input_file,
\&                                 "output=s" => \e$output_file);
.Ve
.PP
.Vb 3
\&      # GetOptions(), and subsequently TIGR_GetOptions(), leaves
\&      # the variables unchanged if no corresponding command line
\&      # arguments are parsed.  The passed variables are checked below.
.Ve
.PP
.Vb 1
\&      if (defined $input_file) {
.Ve
.PP
.Vb 5
\&         # The log message is written only if debugging is turned on.
\&         # By default, debugging is off.  To turn on debugging, use the
\&         # '-debug DEBUG_LEVEL' option on the command line.
\&         # In this example, '-debug 1' would set debugging to level 1
\&         # and report these log messages.
.Ve
.PP
.Vb 2
\&         $tfobject->logLocal("My input file is $input_file", 1);
\&      }
.Ve
.PP
.Vb 1
\&      print "Hello world", "\en";
.Ve
.PP
.Vb 5
\&      # This case is similar to the previous one above...
\&      if (defined $output_file) {
\&         $tfobject->logLocal("My output file is $output_file.", 1);
\&      }
\&   }
.Ve
