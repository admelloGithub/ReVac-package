#!/usr/local/bin/perl

=head1 NAME

uniprot_idmapping_to_mldbm.pl - Parses idmapping file generated by uniprot
    which maps Uniprot IDs to other ids into an mldbm for quicker lookup.

=head1 SYNOPSIS

 USAGE: uniprot_idmapping_to_mldbm.pl
       --input_mapping_file=/path/to/idmapping_selected.tab
       --output=/path/to/idmapping_selected.tab.db
     [ --log=/path/to/file.log
       --debug=3
       --help
     ]

=head1 OPTIONS

B<--input_mapping_file,-i>
    The idmapping_selected.tab file downloaded from Uniprot

B<--output,-o>
    Path where the mldbm will be written to

B<--log,-l>
    Logfile.

B<--debug,-d>
    1,2 or 3. Higher values more verbose.

B<--help,-h>
    Print this message

=head1  DESCRIPTION

    
 
=head1  INPUT
    Download the idmapping_selected.tab.gz file from 
    ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/idmapping/

    From Uniprot's README file:
    2) idmapping_selected.tab
    We also provide this tab-delimited table which includes
    the following mappings delimited by tab:

    1. UniProtKB-AC
    2. UniProtKB-ID
    3. GeneID (EntrezGene)
    4. RefSeq
    5. GI
    6. PDB
    7. GO
    8. IPI
    9. UniRef100
    10. UniRef90
    11. UniRef50
    12. UniParc
    13. PIR
    14. NCBI-taxon
    15. MIM
    16. UniGene
    17. PubMed
    18. EMBL
    19. EMBL-CDS
    20. Ensembl
    21. Ensembl_TRS
    22. Ensembl_PRO

=head1 OUTPUT
    The output is an MLDBM (DB_File) file in the following format
    
    $db{ $UniProtKB-AC } = { 
       "UniProtKB-AC" => $UniProtKB-AC,
       "UniProtKB-ID" => $UniProtKB-ID,
       "GeneID" => $GeneID
     ...
       "Ensembl_PROT" => $Ensembl_PROT
    };

    The output is a hash of hash references.  Each hash reference contains
    a set of keys (as listed in the input section) indexed by UniProtKB-AC as
    well as by UniProtKB-ID and UniRef90 IDs.

=head1  CONTACT

    Kevin Galens
    kgalens@gmail.com

=cut

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through);
use Pod::Usage;
use MLDBM "DB_File";
use Data::Dumper;
$|++;

############# GLOBALS AND CONSTANTS ################
my $debug = 1;
my ($ERROR, $WARN, $DEBUG) = (1,2,3);
my $logfh;
my $idmapping_file;
my %data;
####################################################

my %options;
my $results = GetOptions (\%options,
                         "input_mapping_file|i=s",
                         "output|o=s",
                         "log|l=s",
                         "debug|d=s",
                         "help|h"
                          );

&check_options(\%options);

my @header = &setup_columns();

my $count = 0;
open(my $in, "< $idmapping_file") or &_log($ERROR, "Could not open $idmapping_file ($!)");
while( my $line = <$in> ) {
    chomp( $line );
    my $tmp = {};

    print "$count\r" unless( $count % 100 );
    
    my @cols = split("\t", $line);
    for( my $i = 0; $i < scalar(@header); $i++ ) {
        $tmp->{$header[$i]} = ( defined($cols[$i]) ) ? $cols[$i] : "";
    }
    
    $data{$cols[0]} = $tmp;
    $data{$cols[1]} = $tmp;
    $data{$cols[9]} = $tmp;
    $count++;
}
print "$count\n";
close($in);
untie(%data);

sub setup_columns {
    return ("UniProtKB-AC","UniProtKB-ID","GeneID","RefSeq","GI","PDB","GO","IPI",
            "UniRef100","UniRef90","UniRef50","UniParc","PIR","NCBI-taxon","MIM",
            "UniGene","PubMed","EMBL","EMBL-CDS","Ensembl","Ensembl_TRS","Ensembl_PRO");
}

sub check_options {

   my $opts = shift;

   if( $opts->{'help'} ) {
       &_pod;
   }

   if( $opts->{'log'} ) {
       open( $logfh, "> $opts->{'log'}") or die("Can't open log file ($!)");
   }

   foreach my $req ( qw(input_mapping_file output) ) {
       &_log($ERROR, "Option $req is required") unless( $opts->{$req} );
   }

   $idmapping_file = $opts->{'input_mapping_file'};
   my $output = $opts->{'output'};

   tie(%data, "MLDBM", $output) or &_log($ERROR, "Could not tie hash to $output ($!)");
   
}

sub _log {
   my ($level, $msg) = @_;
   if( $level <= $DEBUG ) {
      print STDOUT "$msg\n";
      print $logfh "$msg\n" if( defined( $logfh ) );
      exit(1) if( $level == $ERROR );
   }
}

sub _pod {
    pod2usage( {-exitval => 0, -verbose => 2, -output => \*STDERR} );
}
