.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Ergatis::Common 3"
.TH Ergatis::Common 3 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is just a collection of commonly used methods.  No classes.
.Sh "get_conditional_read_fh( file_path )"
.IX Subsection "get_conditional_read_fh( file_path )"
.RS 4
Accepts a file path as an argument and returns an open, read-only file 
handle for it.  If the file path ends in .gz the file handle is returned
via the gzip \s-1IO\s0 layer.  It also automatically checks for the existence
of a .gz form of the file you pass, so if you pass 'foo.fsa' and only
\&'foo.fsa.gz' exists, you'll still get the correct filehandle.
.Sp
Returns undef if the file and .gz version both don't exist.
.RE
.Sh "get_conditional_write_fh( file_path )"
.IX Subsection "get_conditional_write_fh( file_path )"
.RS 4
Accepts a file path as an argument and returns an open, writeable file 
handle for it.  If the file path ends in .gz the file handle is returned
via the gzip \s-1IO\s0 layer.
.RE
.Sh "parser_referer_url( url )"
.IX Subsection "parser_referer_url( url )"
.RS 4
Sanitizes a \s-1URL\s0 that will be redirected too if needed.
.RE
.Sh "get_project_conf_param( repository_root, section, parameter )"
.IX Subsection "get_project_conf_param( repository_root, section, parameter )"
.RS 4
finds the project.config file within the passed repository root and
extracts the desired parameter, returning it as a string.
.RE
.Sh "get_module_path( root, name )"
.IX Subsection "get_module_path( root, name )"
.RS 4
recursively searches a path (root) for a given module and returns the full
path to that module.  the name passed can be like 'IdGenerator', 'IdGenerator.pm',
or 'Workflow::IdGenerator'.
.RE
.Sh "get_pipeline_templates( path )"
.IX Subsection "get_pipeline_templates( path )"
.RS 4
Searches each directory within the path passed for pipeline templates and returns a data
structure ideal for use with HTML::Template.  The data structure returned looks like:
.Sp
.Vb 8
\&    [
\&        { id => 'pipeline_name', 
\&            path => "$path/pipeline_name",
\&            has_comment => 0,
\&            comment => 'some comment here',
\&            has_build_guide => 1,
\&            component_count => 0, },
\&    ]
.Ve
.Sp
If there is any problem parsing the template it is skipped and excluded from the
data structure returned.  This could happen if the pipelines are stored in a temp
directory where some of the files are automatically removed.
.RE
.Sh "user_logged_in( )"
.IX Subsection "user_logged_in( )"
.RS 4
Checks if a user is currently logged in \- Currently cookie\-based..  Returns the
user name or undef.
.RE
.Sh "get_session($ergatis_cfg)"
.IX Subsection "get_session($ergatis_cfg)"
.RS 4
Retrieves the session for the given user. If a session does not exist a 
session will be created.
.RE
.Sh "is_admin_user($ergatis_cfg)"
.IX Subsection "is_admin_user($ergatis_cfg)"
.RS 4
If an admin user has been defined in the ergatis configuration this subroutine 
will check whether or not the current logged in user is the admin user 
.RE
.ie n .Sh "validate_user_authorization($ergatis_cfg, $project\fP, \f(CW$pipeline_id)"
.el .Sh "validate_user_authorization($ergatis_cfg, \f(CW$project\fP, \f(CW$pipeline_id\fP)"
.IX Subsection "validate_user_authorization($ergatis_cfg, $project, $pipeline_id)"
.RS 4
If per-account pipeline security is enabled via the ergatis.ini config
file this subroutine will authorize a user to view only pipelines (and 
any components of a pipeline) that the user has created himself/herself.
.Sp
If a user attempts to view a pipeline (or any components of a pipeline)
that they did not create they will be redirected to an error page indicating
they do not have proper authorization.
.RE
.Sh "get_account_pipelines($ergatis_cfg)"
.IX Subsection "get_account_pipelines($ergatis_cfg)"
.RS 4
Retrieves all pipelines tied to a given account. If a CGI::Session session 
cannot be retrieved or the per_account_pipelines_list flag is not toggled
in the ergatis.ini file an empty hash will be returned.
.Sp
If the last modified time on the account pipeline list file is newer than
the one recorded in the session metadata the sessions pipeline list will be
refreshed from file.
.RE
.ie n .Sh "add_pipeline_to_user_pipeline_list( $ergatis_cfg\fP, \f(CW$pipeline_id )"
.el .Sh "add_pipeline_to_user_pipeline_list( \f(CW$ergatis_cfg\fP, \f(CW$pipeline_id\fP )"
.IX Subsection "add_pipeline_to_user_pipeline_list( $ergatis_cfg, $pipeline_id )"
.RS 4
Adds a pipeline to the users pipeline list if the per-account pipeline
list flag is enabled in the ergatis.ini
.RE
.ie n .Sh "delete_pipeline_from_user_pipeline_list( $ergatis_cfg\fP, \f(CW$pipeline_id )"
.el .Sh "delete_pipeline_from_user_pipeline_list( \f(CW$ergatis_cfg\fP, \f(CW$pipeline_id\fP )"
.IX Subsection "delete_pipeline_from_user_pipeline_list( $ergatis_cfg, $pipeline_id )"
.RS 4
Deletes a pipeline from the users pipeline list.
.RE
.Sh "get_quick_links( config_ref )"
.IX Subsection "get_quick_links( config_ref )"
.RS 4
reads the ergatis config file and returns a data structure needed by HTML::Template
to display the quick links at the top of most page headers.  the argument passed
must be a Config::IniFiles object from parsing ergatis.ini.  expects this file to
contain a 'quick_links' section with key (label) value (url) pairs.
.RE
.ie n .Sh "print_error_page( %args )"
.el .Sh "print_error_page( \f(CW%args\fP )"
.IX Subsection "print_error_page( %args )"
.RS 4
throws generic error handling page.  allows you to pass an error message and links for
continuation.  example:
.Sp
.Vb 12
\&    print_error_page( ergatis_cfg => $ergatis_cfg,
\&          message => "The pipeline passed couldn't be found ($xml_input).  " .
\&                     "It may have been deleted or there could be a network (NFS) problem.",
\&          links => [ 
\&                        { label => "$project pipeline list", 
\&                          is_last => 0, 
\&                          url => "./pipeline_list.cgi?repository_root=$repository_root" },
\&                        { label => 'try again', 
\&                          is_last => 1, 
\&                          url => "./view_pipeline.cgi?instance=$xml_input" },
\&                   ],
\&    );
.Ve
.Sp
This assumes that you've printed a header already within the calling \s-1CGI\s0 and that you'll
perform an explicit \fIexit()\fR afterwards (as appropriate).
.RE
.ie n .Sh "url_dir_path( $cgi )"
.el .Sh "url_dir_path( \f(CW$cgi\fP )"
.IX Subsection "url_dir_path( $cgi )"
.RS 4
returns the path of the current script, including 
.RE
.Sh "run_system_cmd($cmd)"
.IX Subsection "run_system_cmd($cmd)"
.RS 4
Runs a system command wrapped in an eval to catch any issues that 
could occur during the process. If an error occurs this script will die
spitting out an error.
.RE
