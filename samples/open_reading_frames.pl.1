.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OPEN_READING_FRAMES 1"
.TH OPEN_READING_FRAMES 1 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
open_reading_frames.pl \- orf finding script for GOS sequence data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1USAGE:\s0 open_reading_frames.pl 
            \-\-input_file=/path/to/some_file.fsa || \-\-stdin
            \-\-translation_table=11
          [ \-\-output_dir=/some/dir
            \-\-gzip_output=1
            \-\-beginning_as_start=1
            \-\-end_as_stop=1
            \-\-assume_stops=0 
            \-\-full_orfs=0
            \-\-min_orf_size=180
            \-\-max_orf_size=9999
            \-\-min_unmasked_size=150
            \-\-frames=1,2,3,4,5,6
            \-\-force_methionine=0
            \-\-header_additions='foo=bar,ergatis_id=12345'
            \-\-unknown_aa=X
          ]
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-input_file,\-i\fR
    Provide full path to fasta format sequence file (may contain multiple records).
    Alternatively, input can be accepted from \s-1STDIN\s0 using \-\-stdin flag.
.PP
\&\fB\-\-stdin\fR
    Optional. Instead of providing \-\-input_file, fasta file input can be read from
.PP
\&\fB\-\-output_dir\fR
    Optional. Directory to write output sequence files to. (default=.)
.PP
\&\fB\-\-gzip_output\fR
    Optional. Compress output sequence files using gzip.
.PP
\&\fB\-\-translation_table,\-t\fR
    Translation table to use for \s-1ORF\s0 finding and amino acid translations.
    Provide an integer value specifying a script-supported translation table from
    the following set: (0\-6, 9\-16, 21\-23), or provide the full path to an \s-1EMBOSS\s0
    formatted translation table file.
    \s-1STDIN\s0 using this flag.
.PP
\&\fB\-\-frames\fR
    Optional. Translation frames for which to output ORFs. Values can be:
    'F' (forward frames, 1\-3), 'R' (reverse frames, 4\-6), a comma-delimited string 
    composed of integer values 1\-6 such as '1,4,5,6', or '0' for all six frames (default).
.PP
\&\fB\-\-id_prefix\fR
    Optional.  A string to prepend to the beginning of all generated identifiers.  Attached
    to this will be either '.pep.$n' or '.orf.$n', where \f(CW$n\fR is a sequential integer.
    (default = '')   
.PP
\&\fB\-\-beginning_as_start\fR
    Optional. Treat the beginning of the sequence as a start codon and mark ORFs as partial.
    (default = 1)
.PP
\&\fB\-\-force_methionine\fR
    Optional. Force translation of first codon in any \s-1ORF\s0 as 'M'.
.PP
\&\fB\-\-full_orfs\fR
    Optional. Predicts ORFs from stop codon to stop codon, without requiring start codons.
.PP
\&\fB\-\-end_as_stop\fR
    Optional. Treat the end of the sequence as a stop codon and mark ORFs as partial.
    (default = 1)
.PP
\&\fB\-\-assume_stops\fR
    Optional. Any codon that could be translated as a stop should be. 
    Eg: \s-1TAN\s0 could be a stop codon (\s-1TAG\s0) or tyrosine (Y) but should be marked as a stop codon.
    (default = 1)
.PP
\&\fB\-\-min_orf_size\fR
    Optional. Set the minimum size of ORFs to output. (default = 180)
.PP
\&\fB\-\-max_orf_size\fR
    Optional. Set the maximum size of ORFs to output. (default = 999999999)
.PP
\&\fB\-\-min_unmasked_size\fR
    Optional. The minimum number of non-softmasked bases and \s-1ORF\s0 must contain to be valid. (default = 150)
.PP
\&\fB\-\-unknown_aa\fR
    Optional. Character to use for aa translation of ambiguous or partial non-degenerate codons. (default = 'X')
.PP
\&\fB\-\-debug\fR 
    Debug level.  Use a large number to turn on verbose debugging. 
.PP
\&\fB\-\-log,\-l\fR 
    Log file
.PP
\&\fB\-\-help,\-h\fR
    This help message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This script is a re-implementation of Doug Rusch's \s-1GOS\s0 \s-1ORF\s0 finding script.
.SH "INPUT"
.IX Header "INPUT"
Input should be cleaned na sequence reads.
.SH "OUTPUT"
.IX Header "OUTPUT"
Output will be na and aa sequence of predicted ORFs. Two output files will be created:
    \s-1INPUT_FILE_NAME_BASE\s0.fna[.gz]
    \s-1INPUT_FILE_NAME_BASE\s0.faa[.gz]
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Brett Whitty
\&    bwhitty@tigr.org
.Ve
