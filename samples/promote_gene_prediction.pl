#!/usr/bin/perl

eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell

=head1 NAME

promote_gene_prediction.pl - will create bsml documents that will represent working models from gene 
    prediction bsml.

=head1 SYNOPSIS

USAGE: template.pl 
            --input_bsml=/path/to/file.bsml
            --cds_fasta=/path/to/cds.fsa or list
            --polypeptide_fasta=/path/to/poly.fsa or list
            --output_bsml=output.bsml
            --id_repository=/path/to/id_respository
        [   --log=/path/to/some/logfile
            --debug=4
            --help   ]

=head1 OPTIONS

B<--input_bsml,-i>
    [REQUIRED] The bsml file which contains gene predictions to be promoted to working models

B<--cds_fasta,-c>
    [REQUIRED] The CDS multifasta file or list of individual fasta files which contain sequence information
    pertaining to the gene predictions found in the input_bsml file.  Will also take a comma separated list 
    of multi-fasta or list files.

B<--polypeptide_fasta,-f>
    [REQUIRED] The polypeptide multifasta file or list of individual fasta files which contain sequence
    information for the predicted polypeptides in input_bsml. Will also take a comma separated list 
    of multi-fasta or list files.

B<--output_bsml,-o>
    [REQUIRED] The output bsml file.

B<--id_respository,-r>
    [REQUIRED] A valid id_repository for use with Ergatis::IdGenerator.pm (see IdGenerator perldoc
    for more details).

B<--debug> 
    Debug level.  Use a large number to turn on verbose debugging. 

B<--log,-l> 
    Log file

B<--help,-h>
    This help message

=head1  DESCRIPTION

    Creates promoted working model bsml out of gene prediction bsml.  In general, removing the analysis element
    and making polypeptides and cds into their own sequence elements.  That's it.  See bug #3351.

=head1  INPUT

    Three major inputs into this program.

    1.  Input bsml.         This should be the output bsml of some gene prediction 2bsml script.

    2.  CDS fasta.          This should be a multifasta file (or list of individual files) of all the
                            cds features found within the gene prediction bsml output.  This can be
                            generated by bsml2fasta component.
    
    3.  Polypeptide Fasta.  See CDS fasta, but substitute the word polypeptide for CDS.

    *NOTE: Numbers 2 and 3 are used for Seq-data-import elements.

=head1  OUTPUT

    Will create another bsml file, very similar to the input.  See DESCRIPTION section for 
    differences between the two.

=head1  CONTACT

    Kevin Galens
    kgalens@tigr.org

=cut

#promote_gene_prediction --input_bsml gms.contig.1.mask_by_analysis.glimmer3.bsml --polypeptide_fasta translate_sequence.fsa.list --cds_fasta gms.contig.1.CDS.fsa --output_bsml whatever --id_repository id_repository/ --project prok


use strict;
use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through);
use Pod::Usage;
use Ergatis::Logger;
use Ergatis::IdGenerator;
use XML::Twig;
use File::Copy;
use File::Find;
use Data::Dumper;

## required for proper operation on NFS
##  see SF.net bug 2142533 - https://sourceforge.net/tracker2/?func=detail&aid=2142533&group_id=148765&atid=772583
$File::Find::dont_use_nlink = 1;

my %options = ();
my $results = GetOptions (\%options, 
                          'input_bsml|i=s',
                          'cds_fasta|c=s',
                          'polypeptide_fasta|f=s',
                          'output_bsml|o=s',
                          'id_repository|r=s',
                          'project|p=s',
                          'log|l=s',
                          'debug=s',
                          'help|h') || pod2usage();

## display documentation
if( $options{'help'} ){
    pod2usage( {-exitval => 0, -verbose => 2, -output => \*STDERR} );
}

#Create logger stuff.
my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename();
my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile,
				  'LOG_LEVEL'=>$options{'debug'});
$logger = $logger->get_logger();

################################ GLOBALS ##################################
use constant POLY => 0;
use constant CDS  => 1;
use constant MAP => { 'CDS' => 1, 'polypeptide' => 0 };
my $input_bsml;
my ($output_bsml_fh, $output_bsml_file);
my %seqDataImportMap;
my @fastaInputs;
my $idMaker;
my $project;
my @featureObjects;
my $sdiId = 0;
###########################################################################

## make sure everything passed was peachy
&check_parameters(\%options);


open($output_bsml_fh, "> $output_bsml_file.part") or
    $logger->logdie("Unable to open $output_bsml_file.part ($!)");

#So we need to do that again to write the sequence elements out to the file.
my $twig = new XML::Twig( 'twig_roots' =>
                          { 'Sequence' => \&gatherAndAdd,
                            'Research' => sub {}
                            },
                          'twig_print_outside_roots' => $output_bsml_fh,
                          'pretty_print' => 'indented' );
$twig->parsefile($input_bsml);

close($output_bsml_fh);

move("$output_bsml_file.part", "$output_bsml_file") or
    $logger->logdie("Couldn't move $output_bsml_file.part --> $output_bsml_file");

0;

sub gatherAndAdd {
    my ($twig, $sequence) = @_;
    my %old2newId;

    if( $project eq 'parse' ) {
        $project = $1 if($sequence->att('id') =~ /^(\w+?)\./);
        $logger->logdie("Could not parse project name from id: ".$sequence->att('id')) 
            if( $project eq 'parse' );
    }

	my $fTables = $sequence->first_child('Feature-tables');
	my $featTable;
	$featTable = $fTables->first_child('Feature-table') if($fTables);

    my @featElems;
	@featElems = $featTable->children('Feature') if($featTable);

    #Cycle through the feature elements and remove the link elements.
    #Also, if the feature is of class CDS or polypeptide, add it as a sequence element.
    foreach my $featElem (@featElems) {


        #Remove the link element (which links this feature to the analysis which we are deleting)
        my $link = $featElem->first_child('Link');
        $link->delete() if($link);
        $logger->debug("Removed link from ".$featElem->att('id')) if($logger->is_debug);

        #Create a new id for the feature
        my $newFeatId = $idMaker->next_id( 'type' => $featElem->att('class'), 'project' => $project );
        my $oldId = $featElem->att('id');
        $old2newId{$oldId} = $newFeatId;
        $featElem->set_att( 'id', $newFeatId );

        #If the sequence is not in the mapping constant (the classes of features to turn into 
        #sequence elements) we should skip it.
        next unless(exists(MAP->{$featElem->att('class')}));

        #Add a link to the feature element to links it to the Feature sequence
        my $newLink = 
            new XML::Twig::Elt( 'Link', { 'rel' => 'sequence',
                                          'href' => "#".$featElem->att('id')."_seq" } );
        $newLink->paste( 'last_child', $featElem );

        #Retrieve the interval loc element
        my $intLocElem = $featElem->first_child('Interval-loc');
        
        #Create a new sequence element to add and add it.
        my $newSeq = 
            new XML::Twig::Elt( 'Sequence', { 'id' => $featElem->att('id')."_seq", 
                                              'length' => $intLocElem->att('endpos') - $intLocElem->att('startpos'),
                                              'molecule' => ($featElem->att('class') eq 'CDS') ? 'dna' : 'aa',
                                              'class' => $featElem->att('class'),
                                          } );
        $newSeq->paste( 'before', $sequence );

        #Create the Seq-data-import element and retrieve its source from getSeqDataImport.
        my $source = $seqDataImportMap{ $oldId };
        $logger->logdie("Could not find the fasta file that contains sequence for ".$featElem->att('id')) 
            unless($source);
        my $seqDataImport = 
            new XML::Twig::Elt( 'Seq-data-import', 
                                { 
                                    'source' => $source,
                                    'identifier' => $oldId,
                                    'format' => 'fasta',
                                    'id' => 'Bsml_SDI'.$sdiId } );
        $seqDataImport->paste( $newSeq );

        #This is for the id of the Seq-data-import element.  I'm pretty sure we don't use them.  And
        #the BSML api just creates bogus ids for the anyway.  To make sure that I don't use to of the
        #same ids, I'm creating a bogus one.
        $sdiId++;

        #This forces the $seqDataImport element to have a separate start and end tag, which seems
        #to be a standard here.  One of those unspoken, undocumented ones.
        my $fakeElement = new XML::Twig::Elt( 'fake' );
        $fakeElement->paste( $seqDataImport );
        $fakeElement->delete();
        
        #Finally print the new sequence.
        $newSeq->print();

      
    }

    #This section replaces all the ids in the feature group and feature group members which reference the 
    #Feature elements (whose ids just changed).
	my $featTables;
    $featTables = $sequence->first_child('Feature-tables');
	my @featGroups;
	@featGroups = $featTables->children('Feature-group') if($featTables); 

    #In each feature group are feature group members.  The old fgm (feature-group-member) ids are the keys
    #to look up the new ids in %old2newId.
    foreach my $featGroup ( @featGroups ) {
        my @fgms = $featGroup->children( 'Feature-group-member' );
        $logger->logdie('There were not feature-group-members in Feature-group') 
            unless(@fgms);
        foreach my $fgm ( @fgms ) {
            my $oldId = $fgm->att('featref');
            $logger->logdie("Can't find new id for $oldId") 
                unless( defined( $old2newId{$oldId} ) );
            $fgm->set_att( 'featref', $old2newId{ $oldId } ); 
        }

    }
    
    
    #Print the old sequence, now with less link elements in the features.
    $sequence->print();
    
}

#Takes an input file, list, or directory.  Finds fasta files, then finds deflines.  Parses identifiers
#out of defline and maps these back to the originating file.  Ex.
#
#   file.fsa                                Data Structure:
#   >prok.polypeptide.1                     $seqDataImportMap{'prok.polypeptide.1'} = 'file.fsa';
#   SEQUENCESEQUENCESEQUENCE...
sub setSeqDataImport {
    my $input = shift;
    my $format = 3;  #0 = fsa, 1 = list, 2 = dir;

    $format = 2 if(-d $input);

    #Is $file a list or fasta file?
    open(IN, "<$input") or $logger->logdie("Unable to open $input ($!)");
    my $format = ((my $tmp = <IN>) =~ /^>/) ? 1 : 0;
    seek(IN, 0, 0);

    if($format == 1) {
        while(<IN>) {
            next unless(/^>(\S*)/);
            $seqDataImportMap{$1} = $input;
        } 
        
    } elsif($format == 0) {
        while(my $fsaFile = <IN>) {
            chomp $fsaFile;
            open(FSA, "< $fsaFile") or $logger->logdie("Unable to open $fsaFile ($!)");
            while(my $line = <FSA>) {
                chomp $line;
                next unless($line =~ /^>(\S*)/);
                $seqDataImportMap{$1} = $fsaFile;
            }

            close(FSA);
        }
    } elsif($format == 2) {
        
        #If we were given a directory
        find( \&wanted, $input );
            
    } else {
        $logger->logdie("Could not determine the format of input $input");
    }

    close(IN);
}

sub wanted {
    return unless($File::Find::name =~ /.*fsa/);
    my $fsaFile = $File::Find::name;
    
    open(IN, "<$fsaFile") or $logger->logdie("Unable to open $fsaFile ($!)");
    
    while(my $line = <IN>) {
        next unless($line =~ /^>(\S*)/);
        $seqDataImportMap{$1} = $File::Find::name;
    }

    close(IN);
    
}

#Check Parameters and set variables.  Set up the state of the program.
sub check_parameters {
    my $opt = shift;
    my $errStr = "";
    
    #Make sure input is provided.
    if($opt->{'input_bsml'}) {
        $errStr .= "Option input_bsml ($opt->{input_bsml}) does not exist\n" unless( -e $opt->{'input_bsml'} );
        $input_bsml = $opt->{'input_bsml'};
    } else {
        $errStr .= "Option input_bsml is required\n";
    }
    
    #Project option
    if( $opt->{'project'} ) {
        $project = $opt->{'project'};
    } else {
        $project = 'parse';
    }

    #Make sure the cds_fasta was included
    if($opt->{'cds_fasta'}) {
        my @inputs = split(/,/, $opt->{'cds_fasta'});
        foreach my $input ( @inputs ) {
            &setSeqDataImport( $input );
        }
    } else {
        $errStr .= "Option cds_fasta is required\n";
    }

    #Make sure the polypeptide_fasta was included
    if($opt->{'polypeptide_fasta'}) {
        my @inputs = split(/,/, $opt->{'polypeptide_fasta'});
        foreach my $input ( @inputs ) {
            &setSeqDataImport( $input );
        }
    } else {
        $errStr .= "Option polypeptide_fasta is required\n";
    }

    #Make sure the output_bsml was included
    unless($opt->{'output_bsml'}) {
        $errStr .= "Option output_bsml is required\n";
    } else {
        open($output_bsml_fh, "> $opt->{'output_bsml'}") or
            $logger->logdie("Unable to open $opt->{'output_bsml'} for writing ($!)");
        $output_bsml_file = $opt->{'output_bsml'};
    }

    #Make sure the id_repository was included
    if($opt->{'id_repository'}) {
        $idMaker = new Ergatis::IdGenerator(  'id_repository' => $options{'id_repository'} );
        $idMaker->set_pool_size( 'exon'        => 40,
                                 'transcript'  => 40,
                                 'gene'        => 40,
                                 'polypeptide' => 40,
                                 'CDS'         => 40 );
    } else {
        $errStr .= "Option id_repository is required\n";
    }

    if($errStr) {
        $logger->logdie($errStr);
    }
    
}
