.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Ergatis::IdGenerator::RandomIdGenerator 3"
.TH Ergatis::IdGenerator::RandomIdGenerator 3 "2015-07-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
RandomIdGenerator.pm \- A module for creating unique feature or pipeline IDs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Ergatis::IdGenerator;
.Ve
.PP
.Vb 1
\&    my $idgen = Ergatis::IdGenerator->new( id_repository => '/path/to/some/id_repository' );
.Ve
.PP
.Vb 2
\&    ## to get a new pipeline id
\&    my $pipelineid = $idgen->next_id( type => 'pipeline' );
.Ve
.PP
.Vb 2
\&    ## optional. set the size of the ID pool for any feature types.  (more efficient)
\&    $idgen->set_pool_size( exon => 40, transcript => 20 );
.Ve
.PP
.Vb 3
\&    ## get get a single id
\&    ## we have to specify a project here unless it was specified when calling new
\&    my $transcript_id = $idgen->next_id( type => 'transcript', project => 'aa1' );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a module for creating unique pipeline/feature IDs for Ergatis. It works 
via two methods depending on the type of \s-1ID\s0 requested.
.PP
Pipeline \s-1ID\s0 \- If a pipeline \s-1ID\s0 is requested a unique \s-1ID\s0 is generted using the 
              Data::UUID module. This \s-1ID\s0 will be totally random as prevent users
              from guessing pipeline \s-1ID\s0's that they may not have access too.
.PP
Feature \s-1ID\s0 \- Works based on an incremented file method designed to handle simultaneous 
             \s-1ID\s0 requests from multiple processes, users and hosts over \s-1NFS\s0.  The module 
             currently uses the File::NFSLock module.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fI\s-1PACKAGE\s0\fR\->new( /%options )" 3
.IX Item "PACKAGE->new( /%options )"
creates the IdGenerator object.  
.RS 3
.IP "\fBoptions\fR" 5
.IX Item "options"
.PD 0
.IP "\fIid_repository\fR" 5
.IX Item "id_repository"
.PD
required.  this is the path to a directory made to serve as an \s-1ID\s0 repository for 
unique \s-1ID\s0 generation.  see the \s-1ID\s0 \s-1REPOSITORY\s0 section below for details.
.IP "\fIlogging\fR" 5
.IX Item "logging"
Optional. Boolean switch ( 1 or 0 ) to turn on/off logging (default = 1).
.IP "\fIlog_dir\fR" 5
.IX Item "log_dir"
Optional. When logging is turned on, this designates the root where log files will
be written.  Within it, a directory will be created for each host accessing
this module.  Within that directory individual log files will be created
for each process.  By default, this will be created as 'logs' directory under
the id_repository.
.RE
.RS 3
.RE
.IP "\fI$OBJ\fR\->next_id( )" 3
.IX Item "$OBJ->next_id( )"
This returns the next available \s-1ID\s0 of the passed type and increments the counter 
for subsequent requests.
.RS 3
.IP "\fBoptions\fR" 5
.IX Item "options"
.PD 0
.IP "\fItype\fR" 5
.IX Item "type"
.PD
Required.  This corresponds to the \s-1CV\s0 term (\s-1SO\s0, \s-1SOFA\s0, other) representing the feature
type you want to create.
.IP "\fIproject\fR" 5
.IX Item "project"
Required for non\-'pipeline' types.  This is usually a short abbreviation for the
project/database the feature belongs to such as 'aa1' for Aedes aegypti.
.IP "\fIcount\fR" 5
.IX Item "count"
Optional.  Use this is you want to reserve multiple IDs at once.  IDs will be
returned as an array reference.  (default = 1)
.IP "\fIversion\fR" 5
.IX Item "version"
Optional.  The IDs returned by this module contain version information.  Use this
option to overwrite the default version (1).
.RE
.RS 3
.RE
.IP "\fI$OBJ\fR\->set_pool_size( some_type => N );" 3
.IX Item "$OBJ->set_pool_size( some_type => N );"
This method allows for more efficient \s-1ID\s0 retrieval by telling the module to pull
blocks of IDs and then use that pool when calling the \fInext_id()\fR method instead of
hitting the file system for each request.  This helps to decrease instances of
heavily locked files and should always be used if possible.  This method can be used
to set (or overwrite) the pool size for as many feature types as necessary by passing
the types and values as a hash (key = type, value = pool size).
.Sp
Unused IDs in a pool are \s-1NOT\s0 returned to other processes, so you should attempt to
set a reasonable value here instead of just pooling an arbitrary, overly-large number.
.SH "NAMING CONVENTION"
.IX Header "NAMING CONVENTION"
This module will return either pipeline IDs or feature IDs, depending on the
value used in the \-\-type option.  For pipeline IDs, a simple incremented integer
is returned.  Feature IDs contain more information, such as project, feature
type and versioning information.  The current format is like:
.PP
.Vb 1
\&    aa1.transcript.14820.1
.Ve
.PP
This feature \s-1ID\s0 indicates version 1 of transcript #14820 in the aa1 project.
.SH "ID REPOSITORY"
.IX Header "ID REPOSITORY"
It is easy to set up an \s-1ID\s0 repository, but it must be done prior to using the 
module.  This prevents random directories from being accidentally used as
\&\s-1ID\s0 repositories.  To set up a directory, just do this:
.PP
.Vb 2
\&    mkdir /path/to/some/id_repository
\&    touch /path/to/some/id_repository/valid_id_repository
.Ve
.PP
The second command will create an empty file that just serves as a marker
to indicate that the directory is meant for \s-1ID\s0 generation.  The module will
take care of any other necessary file and directory structure needs.
.PP
This directory will be checked the first time \fInext_id()\fR is called.
.SH "TO DO / IMPROVEMENTS"
.IX Header "TO DO / IMPROVEMENTS"
Some signal handling is done to attempt to ensure an \s-1ID\s0 file isn't left in a locked
or incomplete state if a process is killed.  The File::NFSLock module does occasionally
leave some temp and .NFSLock files behind when this happens, but they do not affect
other processes (in my testing).  More testing and handling could be done here.
.PP
There are other modules that claim to provide locking functionality, namely
DotLock and IPC::Locker.  While performance is definitely important, I'm primarily 
interested in getting something working without any race conditions.  I plan to
play with these other modules to see if they are equally stable and test
if they may give a performance advantage.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&    Joshua Orvis
\&    jorvis@tigr.org
.Ve
.PP
.Vb 2
\&    Cesar Arze
\&    carze@som.umaryland.edu
.Ve
